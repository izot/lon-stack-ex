/*
 * Filename: FtxlApi.cpp
 *
 * Copyright Â© 2022 Dialog Semiconductor
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in 
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Description: This file contains the implementation of the IzoT SDK Device Stack API 
 *
 */
#include "FtxlStack.h"
#include "FtxlApiInternal.h"
#include "vxlTarget.h" // For vxlSetReportEventLevel.
#include "version.h"
#include "vermacro.h"
#include "LtaDefine.h"

#if FEATURE_INCLUDED(IP852)
#include "LtIpChannel.h"
#ifdef WIN32
#undef ERROR
#include <WinSock.h>
#else
#include <arpa/inet.h>
#endif  // WIN32
#endif

#if PRODUCT_IS(IZOT)
#include "LtUri.h"
#endif

#if defined(IZOT_PLATFORM)
#include "IzoTNiConfig.h"
#endif

/*=============================================================================
 *                           Data Declarations                                *
 *===========================================================================*/

FtxlStack *pMyStack = NULL;

LtLogicalChannel *pChannel = NULL;
boolean stackStarted = false;
boolean printTimeStamp = true;
FILE *fpTracefile = NULL;
#if PRODUCT_IS(IZOT)
LtUri myDeviceUri;
#endif


/*=============================================================================
 *                           SUPPORT FUNCTIONS                                *
 *===========================================================================*/

void APIDebug(const char * fmt, ...)
{
    if (fpTracefile != NULL)
    {
        if (printTimeStamp)
        {
            // Print time stamp
            char *pAsctimeStr;  
            time_t dateTime;
            time(&dateTime);  // Get time in seconds
            pAsctimeStr = asctime(localtime(&dateTime));  // get local time as string
            // Remove the \n 
            char *pos = strchr(pAsctimeStr, '\n');
            *pos = '\0';
            fprintf(fpTracefile, "[%s]", pAsctimeStr);
        }

        va_list args;
        va_start(args, fmt);
        vfprintf(fpTracefile, fmt, args);
        va_end(args);
        fflush(fpTracefile);
    }
}

inline LonApiError checkCreated()
{
	return pMyStack == NULL ? LonApiNotInitialized : LonApiNoError;
}

inline LonApiError checkStarting()
{
	if (pMyStack == NULL)
        return LonApiNotInitialized;
    else if (stackStarted)
        return LonApiNotAllowed;
    else
        return LonApiNoError;
}

inline LonApiError checkInit() 
{	
	return pMyStack == NULL || !stackStarted ? LonApiNotInitialized : LonApiNoError;
}

void deleteStack()
{
    delete pMyStack;
	pMyStack = NULL;
    delete pChannel;
    pChannel = NULL;
	stackStarted = false;
}

inline static LonApiError LonSts(LtErrorType ltSts)
{
    LonApiError sts = FtxlStack::lt2LonError(ltSts);
    return sts;
}

static LonApiError checkInitOnline(void)
{
	LonApiError sts = checkInit();
	if (LON_SUCCESS(sts))
	{
        if (!pMyStack->isConfiguredAndOnline())
        {
            sts = LonApiOffline;
        }
    }
    return sts;
}

/*=============================================================================
 *                              LID FUNCTIONS                                 *
 *===========================================================================*/

/*
 * Function: LonLidCreateStack
 * Internally creates the IzoT stack object, initializes it, and unlocks and 
 * initializes the IzoT transceiver.  This function is the first function 
 * called by the LID generated LonInit Function. 
 *
 * Parameters:
 * pInterface - Pointer to LonStackInterfaceData structure.  This contains  
 *   data generated by LID to define the static attributes of the program 
 * pControlData - Pointer to the LonControlData structure.  This contains data 
 *   used to control the runtime aspects of the stack.  These may be set by the 
 *   application at runtime.  The LID will generate a default control block, 
 *   which the application can (optionally) modify before calling LonInit
 *
 * Returns:
 * <LonApiError>.
 * 
 * Initializes and configures the IzoT driver and the IzoT Stack. This must be 
 * the first call into the IzoT API, and cannot be called again until 
 * LonLidDestroyStack() has been called.  After this function has been called 
 * the following functions can be called:  LonLidRegisterStaticNv(), 
 * LonLidRegisterMemoryWindow(), LonLidStartStack(), and LonLidDestroyStack().
 *
 * Note that the stack expects reasonable values for all of the initialization 
 * parameters, since typically these will be created and validated by LID.  
 * Therefore the stack will not attempt to provide detailed error information 
 * when a parameter is out of range.
 *
 * If <LonLidCreateStack> returns any error, the stack will simply not function.  
 * It will not send or receive  messages over the network.  The service LED 
 * will be left on (applicationless).
 *
 */
FTXL_EXTERNAL_FN const LonApiError 
    LonLidCreateStack(const LonStackInterfaceData* const pInterface,
                      const LonControlData       * const pControlData)
{
    LonApiError sts = LonApiNoError;
    char szFsPath[MAX_PATH];

    APIDebug("Start LonLidCreateStack\n");
    APIDebug("Version: %d\n", pInterface->Version);
    APIDebug("Signature: 0x%x\n", pInterface->Signature);
    APIDebug("ProgramId: %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n", 
     pInterface->ProgramId[0], pInterface->ProgramId[1],pInterface->ProgramId[2],pInterface->ProgramId[3], 
     pInterface->ProgramId[4], pInterface->ProgramId[5], pInterface->ProgramId[6],pInterface->ProgramId[7]);
    APIDebug("StaticNvCount: %d\n", pInterface->StaticNvCount);
    APIDebug("NvTblSize: %d\n", pInterface->NvTblSize);
    APIDebug("DomainTblSize: %d\n", pInterface->DomainTblSize);
    APIDebug("AddrTblSize: %d\n", pInterface->AddrTblSize);
    APIDebug("AliasTblSize: %d\n", pInterface->AliasTblSize);
    APIDebug("BindableMsgTagCount: %d\n", pInterface->BindableMsgTagCount);
  	APIDebug("NodeSdString: %s\n", (pInterface->NodeSdString != NULL) ? pInterface->NodeSdString : "NULL");
    APIDebug("AvgDynNvSdLength: %d\n\n", pInterface->AvgDynNvSdLength);

    APIDebug("Version: %d\n", pControlData->Version);
    APIDebug("ServicePinInterval: %d\n", pControlData->ServicePinInterval);
    APIDebug("NvdFlushGuardTimeout: %d\n", pControlData->NvdFlushGuardTimeout);
    APIDebug("TransceiverType: %d\n", pControlData->CommParmeters.TransceiverType);
    APIDebug("CommParms: ");
    printTimeStamp = false;
    for (int i = 0; i < FTXL_NUM_COMM_BYTES; ++i)
        APIDebug("%02x ", pControlData->CommParmeters.CommParms[i]);
    APIDebug("\n");
    printTimeStamp = true;
    APIDebug("PriorityMsgOutCount: %d\n", pControlData->Buffers.ApplicationBuffers.PriorityMsgOutCount);
    APIDebug("NonPriorityMsgOutCount: %d\n", pControlData->Buffers.ApplicationBuffers.NonPriorityMsgOutCount);
    APIDebug("MsgInCount: %d\n", pControlData->Buffers.ApplicationBuffers.MsgInCount);
    APIDebug("LinkLayerBufferCount: %d\n", pControlData->Buffers.LinkLayerBuffers.LinkLayerBufferCount);
    APIDebug("NetworkBufferInputSize: %d\n", pControlData->Buffers.TransceiverBuffers.NetworkBufferInputSize);
    APIDebug("NetworkBufferOutputSize: %d\n", pControlData->Buffers.TransceiverBuffers.NetworkBufferOutputSize);
    APIDebug("PriorityNetworkOutCount: %d\n", pControlData->Buffers.TransceiverBuffers.PriorityNetworkOutCount);
    APIDebug("NonPriorityNetworkOutCount: %d\n", pControlData->Buffers.TransceiverBuffers.NonPriorityNetworkOutCount);
    APIDebug("NetworkInCount: %d\n", pControlData->Buffers.TransceiverBuffers.NetworkInCount);
    APIDebug("ReceiveTransCount: %d\n", pControlData->ReceiveTransCount);
    APIDebug("TransmitTransCount: %d\n", pControlData->TransmitTransCount);    
    APIDebug("TransmitTransIdLifetime: %d\n", pControlData->TransmitTransIdLifetime);    

    if (pChannel != NULL)
    {
        sts = LonApiNotAllowed;
    }
    else
    {
        vxlReportEvent("createStack called\n");
		LontalkStackUriScheme chnlType;
#if PRODUCT_IS(IZOT)
		chnlType = myDeviceUri.getScheme();
#elif FEATURE_INCLUDED(IP852)
		chnlType = IPUnicast;
#else 
		chnlType = Ldv;
#endif

#if FEATURE_INCLUDED(IP852)
		if (chnlType <= IPMulticast)
		{
			// IP852 Channel
			int ipAddress;
			int ipPort;
			int mcastAddress = 0;
#if PRODUCT_IS(IZOT) 
			ipAddress       = myDeviceUri.getIPAddress();
			ipPort          = myDeviceUri.getPort();
			mcastAddress    = myDeviceUri.getMulticastIPAddress();
#else
			// Needs to support the LTS that compatible with LID example
			// The LonGetMyIpAddress is implemented in the user's app
			LonGetMyIpAddress(&ipAddress, &ipPort);
#endif
			// Commented out the following. Allow to specify zero IP address
			//if (ipAddress == 0)
			//    sts = LonApiNoIpAddress;
			//else
			pChannel = new LtIpLogicalChannel(0, ipAddress, ipPort, null, null, mcastAddress);
			if ((ipAddress == 0) && (pChannel != NULL))
			{
				// Trace the local IP address 
				APIDebug("Local IP Address: %d \n", ((LtIpLogicalChannel *)pChannel)->getLocalIpAddress());
			}
		}
#endif

#if !FEATURE_INCLUDED(IP852) || defined(IZOT_PLATFORM)
		if (chnlType > IPMulticast)
		{
			const char *niName;

#if PRODUCT_IS(IZOT) 
			niName = myDeviceUri.getNiName();
#else
			// Needs to support the LTS that compatible with LID example
			// The LonGetMyIpAddress is implemented in the user's app
			niName = LonGetMyNetworkInterface();
#endif  // PRODUCT_IS(IZOT)

			if (niName == NULL)
			{
				sts = LonApiNoNetworkInterface;
			}
			else
			{
				if (chnlType == IPNative || chnlType == IPNativeEnhanced)
				{
#if PRODUCT_IS(IZOT) 
					char szIpIfName[256];
                    const char *ipIfName = myDeviceUri.getIPInterfaceName();
                    int port = myDeviceUri.getPort();

                    // Get the IP management option from device URI. 
                    // The default is to enable the option to set the IP Address (LONLINK_IZOT_MGMNT_OPTION_SET_IP_ADDR)
					int ipManagementOptions = myDeviceUri.getIPManagementOption();
					if (ipIfName != NULL)
					{
						strcpy(szIpIfName, ipIfName);
#ifdef WIN32
                        if (!strcmp(ipIfName, "wlan"))
                            strcpy(szIpIfName, WIFI_ADAPTER_NAME);
                        else if (!strcmp(ipIfName, "eth"))
                            strcpy(szIpIfName, ETH_ADAPTER_NAME);
#endif
					}
					else
					    szIpIfName[0] = '\0';

					// Allow port number to be other than 2541 for testing purpose
					if (port != IPV6_LS_UDP_PORT)
						gLsUdpPort = port;
#ifndef WIN32
					if (!strncmp(szIpIfName, "lon", 3))
					    // Using a raw socket to connect to LT channel
					    pChannel = new LtLtLogicalChannel(szIpIfName, ipManagementOptions);
					else
#endif
					    pChannel = new LtLtLogicalChannel(niName, (ipIfName != NULL) ? szIpIfName : NULL,
					                                ipManagementOptions);
#else
                    // Device type is not supported in this product
                    sts = LonUnknownLTSDeviceType;
#endif
				}
				else
				{
					// Base receive queue depth on app message in count.
					int receiveQueueDepth = pControlData->Buffers.ApplicationBuffers.MsgInCount;

					// channelPackets must be greater than receive queue depth so that we have
					// some packets in the channel that have not been consumed by the input queue;
					int numChannelPackets = 2*receiveQueueDepth;
					int transmitQueueDepth = pControlData->Buffers.ApplicationBuffers.NonPriorityMsgOutCount +
                                 pControlData->Buffers.ApplicationBuffers.PriorityMsgOutCount;
					pChannel = new LtLtLogicalChannel(niName, numChannelPackets, 
                                        receiveQueueDepth, transmitQueueDepth);
				}
			}
        }
#endif
        if (sts == LonApiNoError)
        {
            vxlReportEvent("Channel created\n");
            sts = LonSts(pChannel->getStartError());
    #if FEATURE_INCLUDED(LONLINK)
            if (chnlType > IPMulticast)  // IP852 Multicast/Unicast channel doesn't use LonLink
            	if (sts == LonApiNoError && !((LtLtLogicalChannel *)pChannel)->getLonLink()->isOpen())
            	{
            		sts = LonApiInitializationFailure;
            	}
    #endif
        }

        if (LON_SUCCESS(sts))
        {
            LonUniqueId uid;
#if FEATURE_INCLUDED(IP852) || !FEATURE_INCLUDED(LONLINK)
            // If the app has registered a valid uniqueID, LTS will use the app's specified uniqueID.
            // Otherwise it uses the uniqueID saved in NVD folder or generates a random one if no unique Id
            sts = LonGetUniqueId(&uid);
#else
            // Since the IzoT API only supports one stack, use the unique ID 
            // of the underlying interface - layer 2 mips don't use their
            // unique IDs.  If you want to change the IzoT API to support more than
            // one interface, you will need to obtain and register a unique ID
            // for each stack.
            LtUniqueId deviceId;
            ((LtLtLogicalChannel *)pChannel)->getLonLink()->getUniqueId(deviceId);
            memcpy(uid, deviceId.getData(), sizeof(LonUniqueId));
#endif
            sts = LonRegisterUniqueId((LonUniqueId *)&uid);   
        }

        if (sts == LonApiNoError)
        {
            pMyStack = new FtxlStack(pChannel, pControlData);
            vxlReportEvent("Stack created\n");
            LonGetNvdFsPath(szFsPath, sizeof(szFsPath));
            sts = pMyStack->createStack(pInterface, pControlData, (const char *)&szFsPath);
        }
        else
        {
            vxlReportError((char *)"Driver failed to open\n");
        }

        if (!LON_SUCCESS(sts))
        {
            deleteStack();
        }
    }
    APIDebug("End LonLidCreateStack = %d\n", sts);
    return sts;
}


#if PRODUCT_IS(IZOT)
#if FEATURE_INCLUDED(IP852)
/*
 *  Function: LonGetMyIpAddress
 *  Get the IP address and port number of an IP852 interface.  
 *
 *  Returns:
 *  void.
 * 
 *  Remarks:
 *  Returns the IP address and port used for an IP852 interface.  
 */
FTXL_EXTERNAL_FN void LonGetMyIpAddress(int *pAddress, int *pPort)
{
    *pAddress = 0;
    *pPort = 0;
    if (pChannel != NULL)
    {
        *pAddress = ((LtIpLogicalChannel *)pChannel)->getIpAddress();
        *pPort = ((LtIpLogicalChannel *)pChannel)->getIpPort();
        APIDebug("LonGetMyIpAddress = %d - %d\n", *pAddress, *pPort);
    }
    else
       APIDebug("LonGetMyIpAddress = IP address is not configured");
}

#else
/*
 *  Function: LonGetMyNetworkInterface
 *  Get the network interface name to use to open the native LonTalk interface.  
 *
 *  Returns:
 *  Name of network interface.
 * 
 *  Remarks:
 *  Returns the name of the network interface, such as the serial port name.  
 */
FTXL_EXTERNAL_FN const char *LonGetMyNetworkInterface(void)
{
    return pChannel->getName();
}
#endif
#endif

/*
 *  Function: LonGenerateUniqueId
 *  Generates uniqueID.  The first byte is always FE (currently used for virtual neuron IDs).
 *  To avoid looking like a virtual neuron ID (whose format is FEAAAAAAAAxxxx) the second byte 
 *  can be any value but AA (this allows virtual neuron ID space to increase dramatically).  
 *  The remaining bytes can take on any value.  This gives a space of 255 * 2^32.  
 *  The 5 variable bytes are chosen at random (using the time of day clock as a seed).  
 *  This obviously is not guaranteed to produce unique neuron Ids.  The odds of having two 
 *  virtual network interfaces with the same neuron ID where the number of virtual network 
 *  interfaces is N, is approximately given by the following formula:  (255*2^32) / ((n^2)/2).  
 *  Assuming that you have less than 100 virtual network interfaces the odds of a collision is 
 *  less than 2 billion to one.  
 *       
 *  Parameters:
 *  pDeviceID - pointer receive the new random generated unique Id.
 *
 *  Returns:
 *  <LonApiError>.
 * 
 *  Remarks:
 *   
 */ 
FTXL_EXTERNAL_FN const LonApiError LonGenerateUniqueId(LonUniqueId* pDeviceID)
{
    APIDebug("Start LonGenerateUniqueId\n"); 
    LtUniqueId deviceId;
    LtPlatform::generateUniqueId(&deviceId);

    memcpy(pDeviceID, deviceId.getData(), sizeof(LonUniqueId));
    APIDebug("DeviceID: ");
    printTimeStamp = false;
    for (int i = 0; i < 6; ++i)
        APIDebug("%02x ", deviceId.getData(i));
    APIDebug("\n");
    printTimeStamp = true;
    APIDebug("End LonGenerateUniqueId = %d\n", LonApiNoError); 
    return LonApiNoError;
}

/*
 * Function: LonLidRegisterStaticNv
 * Adds a static network variable.
 *
 * Parameters:
 * pNvDef - pointer to a LonNvDefinition struct
 *
 * Returns:
 * <LonApiError>.
 * 
 *  This function register static network variables with the IzoT stack, and 
 *  is called once for each static network variable from the LID generated 
 *  LonInit function.  This function may be called only after <LonLidCreateStack> 
 *  and before <LonLidStartStack>.
 *
 */
const LonApiError LonLidRegisterStaticNv(const LonNvDefinition* const pNvDef)
{
    APIDebug("Start LonLidRegisterStaticNv\n");

    LonApiError sts = checkStarting();

    if (sts == LonApiNoError)
    {
        if (pNvDef->Version != LON_NV_DEFINITION_CURRENT_VERSION)
        {
            sts = LonApiVersionNotSupported;
        }
    }

    APIDebug("Version = %d\n", pNvDef->Version);
    APIDebug("PValue = %d\n", pNvDef->PValue);
    APIDebug("DeclaredSize = %d\n", pNvDef->DeclaredSize);
    APIDebug("SnvtId = %d\n", pNvDef->SnvtId);
    APIDebug("ArrayCount = %d\n", pNvDef->ArrayCount);
    APIDebug("Flags = %d\n", pNvDef->Flags);
    APIDebug("Name = %s\n", (pNvDef->Name != NULL) ? pNvDef->Name : "NULL");
    APIDebug("SdString = %s\n", (pNvDef->SdString != NULL) ? pNvDef->SdString : "NULL");
    APIDebug("MaxRate = %d\n", pNvDef->MaxRate);
    APIDebug("MeanRate = %d\n", pNvDef->MeanRate);

    if (sts == LonApiNoError)
    {
        int flags = pNvDef->Flags & ~(LON_NV_IS_OUTPUT);
        if (flags & NV_SD_CHANGEABLE)
        {
            // If the type can change, we might be able to change the size as well
            // (don't know).  Mark it as changeable size so that the app can
            // decide.
            flags |= NV_SD_CHANGEABLE_LENGTH;
        }
        if (!(flags & NV_SD_AUTH_CONFIG))
        {
            flags |= NV_SD_AUTH_NONCONFIG;
        }
        if (!(flags & NV_SD_PRIORITY_CONFIG))
        {
            flags |= NV_SD_PRIORITY_NONCONFIG;
        }
        if (!(flags & NV_SD_SERVICE_CONFIG))
        {
            flags |= NV_SD_SERVICE_NONCONFIG;
        }

        LtNetworkVariable *pNv = 
            new LtNetworkVariable((byte *)pNvDef->PValue,
                                  pNvDef->DeclaredSize, 
                                  pNvDef->SnvtId, 
                                  pNvDef->ArrayCount, 
                                  pNvDef->Flags & LON_NV_IS_OUTPUT ? true : false,
                                  flags,
                                  (char *)pNvDef->Name, 
                                  (char *)pNvDef->SdString, 
                                  pNvDef->MeanRate == LON_NV_RATE_UNKNOWN ? NO_RATE_ESTIMATE : pNvDef->MeanRate,
                                  pNvDef->MaxRate == LON_NV_RATE_UNKNOWN ? NO_RATE_ESTIMATE : pNvDef->MaxRate);

        sts = LonSts(pMyStack->registerNetworkVariable(pNv));
    }
    APIDebug("End LonLidRegisterStaticNv = %d\n", sts);
    return sts;
}

/*
 * Function: LonLidRegisterMemoryWindow
 * Register memory addresses to be mapped to LID managed memory.
 *
 * Parameters:
 * windowAddress - The starting (Neuron) address (in host byte order) of the window.
 * windowSize - The size of the window, in bytes.
 *
 * Returns:
 * <LonApiError>.
 * 
 * This function is used to open up a window in the neuron memory space.
 * Any network management memory read using absolute addressing that falls 
 * completely within the window will call the LID generated callback 
 * LonReadMemory().  Any network management memory write using absolute 
 * addressing that falls completely within the window will call the LID 
 * generated callback LonWriteMemory().  
 *
 * This function may only be called after <LonLidCreateStack> and before 
 * <LonLidStartStack>.  The address space for these windows is between 0x0001 
 * and 0xffff. 
 *
 */
const LonApiError LonLidRegisterMemoryWindow(const unsigned int windowAddress, 
									         const unsigned int windowSize)
{
    APIDebug("Start LonLidRegisterMemoryWindow\n");
	LonApiError sts = checkStarting();
	if (LON_SUCCESS(sts))
	{
		pMyStack->registerMemory(windowAddress, windowSize);
	}
    APIDebug("End LonLidRegisterMemoryWindow = %d\n", sts);
	return sts;
}

/*
 * Function: LonLidStartStack
 * Completes the initialization of the stack.  
 *
 * Returns:
 * <LonApiError>.
 * 
 * Starts running the stack.  This is typically the last function called by 
 * LonInit(). It is illegal to call LonLidRegisterStaticNv() or 
 * LonLidRegisterMemoryWindow() after calling this function.  
 *
 */
const LonApiError LonLidStartStack(void)
{
    APIDebug("Start LonLidStartStack\n");
    LonApiError sts = checkStarting();;
	if (sts == LonApiNoError)
	{
		vxlReportEvent("startStack called\n");
		sts = pMyStack->startStack();
        if (LON_SUCCESS(sts))
        {
		    vxlReportEvent("stack initialized successfully\n");
            stackStarted = true;
        }
        else
        {
		    vxlReportEvent("stack initialization failed (sts = %d)\n", sts);
        }
	}
    APIDebug("End LonLidStartStack = %d\n", sts);
    return sts;
}

/*
 * Function: LonLidDestroyStack 
 * Stops the IzoT stack and frees all allocated memory that is owned by it. 
 *
 * Returns:
 * <LonApiError>.
 * 
 * Waits for non-volatile writes to complete, stops the stack and frees all 
 * temporary memory created during execution of the stack.  The service LED is 
 * lit to indicate that the device is applicationless.
 *
 */
void LonLidDestroyStack(void)
{
    APIDebug("Start LonLidDestroyStack\n");
	LonApiError sts = checkCreated();
	if (LON_SUCCESS(sts))
	{
		pMyStack->stopApp();
		stackStarted = false;
	}
#if PRODUCT_IS(IZOT)
	// Deregister all callbackGet functions 
	LonDeregisterAllCallbacks();
#endif
    deleteStack();
    APIDebug("End LonLidDestroyStack = %d\n", sts);
    
    if (fpTracefile != NULL)
    {
        fclose(fpTracefile);
        fpTracefile = NULL;
    }
}

/*=============================================================================
 *                          GENERAL API FUNCTIONS                            *
 *===========================================================================*/

/*
 * Function: LonEventPump
 * Process IzoT events. 
 *
 * This function must be called periodically by the application.  This
 * function processes any events that have been posted by the IzoT Device stack.
 * Typically this function is called in response to the LonEventReady callback, but
 * must not be called directly from the LonEventReady callback. Rather the 
 * the LonEventReady callback can set an operating system event to schedule
 * the main application task to call this function.
 *
 * This function must be called at least ###TBD supply required minimum frequency###.
 */
FTXL_EXTERNAL_FN void LonEventPump()
{
	LonApiError sts = checkInit();
	if (LON_SUCCESS(sts))
	{
		pMyStack->eventPump();
	}
}

/*
 *  Function: LonGetVersion
 *  Returns the Izot Device Stack API version number.
 *
 *  Parameters:
 *  pMajorVersion - pointer to receive the Izot Device Stack API's major version 
 *      number.
 *  pMinorVersion - pointer to receive the Izot Device Stack API's minor version 
 *      number.
 *  pBuildNumber - pointer to receive the Izot Device Stack API's build number.
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Remarks:
 *  This function provides the version of the Izot Device Stack API.  Note that 
 *  this function can be called at any time, including prior to calling <LonLidCreateStack>. 
 */
FTXL_EXTERNAL_FN const LonApiError LonGetVersion(unsigned* const pMajorVersion, 
                                                 unsigned* const pMinorVersion,
                                                 unsigned* const pBuildNumber)
{
    APIDebug("Start LonGetVersion\n");
    *pMajorVersion = VER_MAJOR_D;
    *pMinorVersion = VER_MINOR_D;
    *pBuildNumber = VER_BUILD_D;
    APIDebug("End LonGetVersion - %d.%d.%d\n", *pMajorVersion, *pMinorVersion, *pBuildNumber);
    return LonApiNoError;
}

/*
 *  Function: LonSendServicePin
 *  Propagates a service pin message.
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Use this function to propagate a service pin message to the network. 
 *  The function will fail if the device is not yet fully initialized.
 */
const LonApiError LonSendServicePin(void)
{
    APIDebug("Start LonSendServicePin\n");
	LonApiError sts = checkInit();
	if (LON_SUCCESS(sts))
	{
		vxlReportEvent("Send service Pin Message\n");
		pMyStack->sendServicePinMessage();
	}
    APIDebug("End LonSendServicePin = %d\n", sts);
    return sts;
}

/*=============================================================================
 *                          Network Variables                                *
 *===========================================================================*/

/*
 * Function: LonPollNv
 * Polls a bound, polling, input network variable.
 *
 * Parameters:
 * index - local index of the input network variable 
 *
 * Returns:
 * <LonApiError>.
 * 
 * Call this function to poll an input network variable. Polling an input network 
 * variable causes this device to solicit all devices that have output network 
 * variables connected to this input network variable to send their latest value 
 * for the corresponding network variable.
 *
 * The function returns success if the message is successfully put in the transmit 
 * queue to send. Note the successful completion of this function _does not_ 
 * indicate the successful arrival of the requested values. The values received 
 * in response to this poll are reported by a series of <LonNvUpdateOccurred> 
 * callback invocations. 
 *
 * LonPollNv operates on bound input network variables that have been declared 
 * with the Neuron C *polled* attribute, only. 
 */
const LonApiError LonPollNv(const unsigned index)
{
    APIDebug("Start LonPollNv(Index = %d)\n", index);
	LonApiError sts = checkInitOnline();
	if (LON_SUCCESS(sts))
	{
        int arrayIndex;
        LtNetworkVariable *pNv = pMyStack->getNetworkVariable(index, arrayIndex);
        if (pNv == NULL)
        {
            sts = LonApiNvIndexInvalid;
        }
        else if (pNv->getIsOutput())
        {
            sts = LonApiNvPollOutputNv;
        }
        else if (!(pNv->getFlags() & NV_SD_POLLED))
        {
            sts = LonApiNvPollNotPolledNv;
        }
        else if (!pMyStack->poll(index))
        {
            sts = LonApiTxBufIsFull;
        }
    }
    APIDebug("End LonPollNv = %d\n", sts);
    return sts;
}

/*
 *  Function: LonPropagateNv
 *  Propagates the value of a bound output network variable to the network.
 *
 *  Parameters:
 *  index - the index of the network variable
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Remarks:
 *  Note that it is not an error to propagate an unbound non-polled output.  
 *  If this is done, the IzoT Device protocol stack will not send any updates 
 *  to the network, but will generate a <LonNvUpdateCompleted> event with the 
 *  success parameter set to TRUE.
 *
 *  If LonPropagateNv() returns *LonApiNoError*, the <LonNvUpdateCompleted> 
 *  event will be triggered when the NV update has successfully completed or 
 *  failed.  
 *
 *  If LonPropagateNv() is called multiple times before the network variable is 
 *  sent, the behavior is dependent on whether the network variable has the 
 *  synchronous attribute:
 *
 *    - If the network variable is declared with the Neuron C *sync* attribute, 
 *      the network variable will be sent on the network each time 
 *      <LonPropagateNv> is called (subject to application buffer limits).  
 *      The value sent will be the value of the network variable at the time 
 *      of the call to <LonPropagateNv>.  <LonNvUpdateCompleted> will be 
 *      called each time as well.  
 *    
 *    - If the network variable is *not* declared with the Neuron C *sync* 
 *      attribute, only the latest value of the network variable will be sent 
 *      out onto the network, and the <LonNvUpdateCompleted> function will be 
 *      called only once.  If there are no application buffers available, the 
 *      network variable will be propagated at a later time, when one becomes 
 *      available.
 */
const LonApiError LonPropagateNv(const unsigned index)
{
    APIDebug("Start LonPropagateNv(Index = %d)\n", index);
	LonApiError sts = checkInitOnline();
	if (LON_SUCCESS(sts))
	{
        int arrayIndex;
        LtNetworkVariable *pNv = pMyStack->getNetworkVariable(index, arrayIndex);
        if (pNv == NULL)
        {
            sts = LonApiNvIndexInvalid;
        }
        else if (!pNv->getIsOutput())
        {
            sts = LonApiNvPropagateInputNv;
        }
        else if ((pNv->getFlags() & NV_SD_POLLED))
        {
            sts = LonApiNvPropagatePolledNv;
        }
        else if (!pMyStack->propagate(index))
        {
            sts = LonApiTxBufIsFull;
        }
    }
    APIDebug("End LonPropagateNv = %d\n", sts);
    return sts;
}

/*
 *  Function: LonGetDeclaredNvSize
 *  Gets the declared size of a network variable.
 *
 *  Parameters:
 *  index - the index of the network variable
 *
 *  Returns:     
 *  Declared initial size of the network variable as defined in the Neuron C 
 *  model file.  Zero if the network variable corresponding to index doesn't 
 *  exist.
 *
 *  Note that this function *may* be called from the LonGetCurrentNvSize() 
 *  callback.
 */
const unsigned LonGetDeclaredNvSize(const unsigned index)
{
    APIDebug("Start LonGetDeclaredNvSize(Index = %d)\n", index);
    int size = 0;
    LonApiError sts = checkInit();
    if (LON_SUCCESS(sts))
    {
        int arrayIndex;
        LtNetworkVariable *pNv = pMyStack->getNetworkVariable(index, arrayIndex);
        if (pNv != NULL)
        {
            size = pNv->getLength();
        }
    }
    APIDebug("End LonGetDeclaredNvSize = %d, size = %d\n", sts, size);
    return size;
}

/*
 *  Function: LonGetNvValue
 *  Returns a pointer to the network variable value.
 *
 *  Parameters:
 *  index - the index of the network variable
 *
 *  Returns:
 *  Pointer to the network variable value, or NULL if invalid.
 *
 *  Remarks:
 *  You can use this function to obtain a pointer to either a static or
 *  dynamic network variable value.
 */
volatile void* const LonGetNvValue(const unsigned index)
 {
    volatile void* p = NULL;
    // Can't check for stack started, because LonInit calls this during
    // deserialize.
    APIDebug("Start LonGetNvValue(Index = %d)\n", index);
	LonApiError sts = checkCreated();

	if (LON_SUCCESS(sts))
	{
        int arrayIndex;
        LtNetworkVariable *pNv = pMyStack->getNetworkVariable(index, arrayIndex);
        if (pNv != NULL)
        {
            p = pNv->getNvDataPtr(arrayIndex);
        }
	}
    APIDebug("End LonGetNvValue = %d\n", sts);
    return p;
 }

/*
 *  Function: LonSetNvValue
 *  Set a new the network variable value in packed, big-endian.
 *
 *  Parameters:
 *  index - the local index of the network variable
 *  pValue - Pointer to the network variable value to set
 *  nLength - the length of the network variable
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Use this function to set a new the network variable value in packed, big-endian.
 *  This makes it easier for the Python application to pass data to stack which expects
 *  big endian packed byte arrays.
 */
const LonApiError LonSetNvValue(const unsigned index, void* const pValue)
{
    byte *p;

    APIDebug("Start LonSetNvValue(Index = %d)\n", index);
	LonApiError sts = checkCreated();
    
	if (LON_SUCCESS(sts))
	{
        int arrayIndex;
        int nLength;
        LtNetworkVariable *pNv = pMyStack->getNetworkVariable(index, arrayIndex);
        if (pNv != NULL)
        {
            printTimeStamp = false;
            nLength = pNv->getCurLength();
            p = (byte *)pValue;
            for (int i = 0; i < nLength; i++)
            {
                APIDebug("%02X ", *(p+i));
                if (((i+1) % 8) == 0)
                    APIDebug("    ");
                else
                if (((i+1) % 16) == 0)
                    APIDebug("\n");
            }
            APIDebug("\n");
            printTimeStamp = true;
            pNv->setNvData((byte *)pValue, nLength, arrayIndex);
        }
        else
        {
            sts = LonApiNvIndexInvalid;
            APIDebug("NvIndexInvalid\n");
        }
 	}
    APIDebug("End LonSetNvValue = %d\n", sts);
    return sts;
 }

/*
 *  Function: LonQueryNvType
 *  Queries type information about a network variable.
 *
 *  Parameters:
 *  index - the index of the network variable
 *  pNvDef - pointer to a <LonNvDefinition> 
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Remarks:
 *  Use this function to obtain information about a network variable.  The
 *  definition is returned in the <LonNvDefinition> buffer provided.  The
 *  <LonNvDefinition> buffer contains pointers to the network variable name
 *  and self-documentation strings, which are allocated by the IzoT Device Stack API.  
 *  The application must call LonFreeNvTypeData to free these strings
 *  when it is done with them.
 */
const LonApiError LonQueryNvType(const unsigned index, LonNvDefinition* const pNvDef)
{
    APIDebug("Start LonQueryNvType(%d)\n", index);
	LonApiError sts = checkInit();
	if (LON_SUCCESS(sts))
	{
        int arrayIndex;
        LtNetworkVariable *pNv = pMyStack->getNetworkVariable(index, arrayIndex);
        if (pNv == NULL)
        {
            sts = LonApiNvIndexInvalid;
        }
        else
        {
            sts = pMyStack->queryNvType(pNv, arrayIndex, pNvDef);
        }        
    }
    APIDebug("End LonQueryNvType = %d\n", sts);
    return sts;
}

/*
 *  Function: LonFreeNvTypeData
 *  Frees internal buffers allocated by LonQueryNvType.
 *
 *  Parameters:
 *  pNvDef - pointer to a <LonNvDefinition> that was previously initialized by 
 *  LonQueryNvType.
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Use this function to free the internally allocated string buffers 
 *  contained in the <LonNvDefinition> buffer.  Note that this function does
 *  not free the <LonNvDefinition> buffer itself, only the strings that it 
 *  references.
 */
const LonApiError LonFreeNvTypeData(LonNvDefinition* const pNvDef)
{
    APIDebug("Start LonQueryNvType\n");
    FtxlStack::freeNvType(pNvDef);
    APIDebug("End LonQueryNvType - %d\n", LonApiNoError);
    return LonApiNoError;
}

/*=============================================================================
 *                          Explicit Messages                                *
 *===========================================================================*/

/*
 *  Function: LonSendResponse
 *  Sends a response.
 *
 *  Parameters:
 *  pCorrelator - pointer to the correlator, obtained with <LonMsgArrived>
 *  code - response message code
 *  pData - pointer to response data, may be NULL iff len is zero
 *  length - number of valid response data bytes in pData
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  This function is called to send an explicit message response.  The correlator
 *  is passed in to the LonMsgArrived and must be copied and saved if the response 
 *  is to be sent after returning from that routine.  A response code should be 
 *  in the 0x00..0x2f range.
 */
const LonApiError LonSendResponse(const LonCorrelator correlator, 
                                  const LonByte code, 
                                  const LonByte* const pData, 
                                  const unsigned length)
{
    APIDebug("Start LonSendResponse\n");
	LonApiError sts = checkInit();
	if (LON_SUCCESS(sts))
	{
        LtMsgIn *pRequest = (LtMsgIn *)correlator;
        if (pRequest != NULL)
        {
            LtRespOut* pResp = pMyStack->respAlloc(pRequest);
            if (pResp != null)
            {
                pResp->setCode(code);
                pResp->setData((byte *)pData, 0, length);
                if (((unsigned)pResp->getLength()) != length + 1)
                {
                    sts = LonApiMsgLengthTooLong;
                }
                else
                {
	                pMyStack->send(pResp);
                }
            }
            else
            {
                sts = LonApiTxBufIsFull;
            }
            pMyStack->release(pRequest);
        }
        else
        {
            sts = LonApiMsgInvalidCorrelator;
        }
    }
    APIDebug("End LonSendResponse = %d\n", sts);
    return sts;
}

/*
 *  Function: LonReleaseCorrelator
 *  Release a request correlator without sending response.
 *
 *  Parameters:
 *  correlator - The correlator, obtained from <LonMsgArrived>
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  This function is called to release a correlator obtained from 
 *  <LonMsgArrived> without sending are response.  The application must either 
 *  send a response to every message with a service type of request, or release
 *  the correlator, but not both.  
 */
const LonApiError LonReleaseCorrelator(const LonCorrelator correlator)
{
	LonApiError sts = checkInit();
	if (LON_SUCCESS(sts))
	{
        LtMsgIn *pRequest = (LtMsgIn *)correlator;
        if (pRequest != NULL)
        {
            pMyStack->release(pRequest);
        }
        else
        {
            sts = LonApiMsgInvalidCorrelator;
        }
    }
    return sts;
}

/*
 *  Function: LonSendMsg
 *  Send an explicit (non-NV) message.
 *
 *  Parameters:
 *  tag - message tag for this message
 *  priority - priority attribute of the message
 *  serviceType - service type for use with this message
 *  authenticated - TRUE to use authenticated service
 *  pDestAddr - pointer to destination address
 *  code - message code
 *  pData - message data, may be NULL if length is zero
 *  length - number of valid bytes available through pData
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Remarks:
 *  This function is called to send an explicit message.  For application 
 *  messages, the message code should be in the range of 0x00..0x2f.  Codes in 
 *  the 0x30..0x3f range are reserved for protocols such as file transfer.
 *
 *  If the tag field specifies one of the bindable messages tags 
 *  (tag < # bindable message tags), the pDestAddr is ignored (and can be 
 *  NULL) because the message is sent using implicit addressing.
 *
 *  A successful return from this function indicates only that the message has 
 *  been queued to be sent.  If this function returns success, the IzoT Device 
 *  Stack API will call <LonMsgCompleted> with an indication of the 
 *  transmission success.
 *
 *  If the message is a request, <LonResponseArrived> event handlers are 
 *  called when corresponding responses arrive.
 */
const LonApiError LonSendMsg(const unsigned tag, const LonBool priority, 
                             const LonServiceType st, 
                             const LonBool authenticated,
                             const LonSendAddress* const pDestAddr, 
                             const LonByte code, 
                             const LonByte* const pData, const unsigned length)
{
	LonApiError sts = checkInitOnline();
    LtMsgOut *pMsgOut = NULL;
    boolean explicitAddress = false; 

    if (LON_SUCCESS(sts))
	{
        pMsgOut = priority ? pMyStack->msgAllocPriority() :
                                       pMyStack->msgAlloc();
        if (pMsgOut == NULL)
        {
            sts = LonApiTxBufIsFull;
        }
    }
	if (LON_SUCCESS(sts))
    {
        explicitAddress = (tag >= (unsigned)pMyStack->getMessageTagCount());
        pMsgOut->setServiceType((LtServiceType)st);
        pMsgOut->setAuthenticated(authenticated);
        if (explicitAddress)
        {
            if (pDestAddr == NULL)
            {
                sts = LonApiMsgExplicitAddrMissing;
            }
            else
            {
                // Several parameters are in the same place for all addressing types.
                LonAddressType type = (LonAddressType)pDestAddr->SubnetNode.Type;

                int domain = LON_GET_ATTRIBUTE(pDestAddr->SubnetNode, LON_SENDSN_DOMAIN);

                int txTimer;

                if (st == LonServiceRepeated)
                {
                    txTimer = LtMisc::toTxTimer(
                        LON_GET_ATTRIBUTE(pDestAddr->SubnetNode, LON_SENDSN_REPEAT_TIMER));
                }
                else
                {
                    txTimer = LtMisc::toTxTimer(
                        LON_GET_ATTRIBUTE(pDestAddr->SubnetNode, LON_SENDSN_TRANSMIT_TIMER));            
                }

                int retryCount = 
                    LON_GET_ATTRIBUTE(pDestAddr->SubnetNode, LON_SENDSN_RETRY);

                if (type & LON_SENDGROUP_TYPE_MASK)
                {                
                    int groupSize = LON_GET_ATTRIBUTE(pDestAddr->Group, LON_SENDGROUP_SIZE);

                    pMsgOut->getAddr().setGroup(domain, pDestAddr->Group.GroupId, 
                                                groupSize, txTimer, retryCount);
                }
                else
                {
                    switch(type)
                    {
                    case LonAddressSubnetNode:
                        {
                            int node = LON_GET_ATTRIBUTE(pDestAddr->SubnetNode, LON_SENDSN_NODE);

                            pMsgOut->getAddr().setSubnetNode(domain, pDestAddr->SubnetNode.Subnet,
                                                             node, txTimer, retryCount);
                        }
                        break;
                    case LonAddressUniqueId:
                        {
                            LtUniqueId uid((byte *)pDestAddr->UniqueId.NeuronId);

                            pMsgOut->getAddr().setUniqueId(domain, pDestAddr->UniqueId.Subnet,
                                                           uid, txTimer, retryCount);
                        }
                        break;
                    case LonAddressBroadcast:
                        {
                            int backlog = LON_GET_ATTRIBUTE(pDestAddr->Broadcast, LON_SENDBCAST_BACKLOG);
                                                   
                            pMsgOut->getAddr().setBroadcast(domain, pDestAddr->Broadcast.Subnet, 
                                                            backlog, txTimer, retryCount);
                        }
                        break;
                    case LonAddressLocal:
                        pMsgOut->getAddr().setLocal();
                        break;
                    default:
                        sts = LonApiMsgInvalidAddress;
                    }
                }
            }
        }
    }
    if (LON_SUCCESS(sts) && pData == NULL && length != 0)
    {
        sts = LonApiInvalidParameter;
    }

	if (LON_SUCCESS(sts))
    {
        LtMsgTag *pMsgTag = new LtMsgTag(!explicitAddress, tag);

        pMsgOut->setCode(code);
        pMsgOut->setData((byte *)pData, 0, length);
        if (((unsigned)pMsgOut->getLength()) != length + 1)
        {
            sts = LonApiMsgLengthTooLong;
        }
        else
        {
            pMsgOut->setTag(*pMsgTag);
            pMyStack->send(pMsgOut);
        }
    }

    if (!LON_SUCCESS(sts))
    {
        if (pMsgOut != NULL)
        {
            pMyStack->cancel(pMsgOut);
        }
        APIDebug("LonSendMsg = %d\n", sts);
    }
    return (sts);
}

/*
 * ******************************************************************************
 * SECTION: EXTENDED API FUNCTIONS
 * ******************************************************************************
 *
 * This section details extended API functions, update functions and access 
 * functions. These functions are not typically required and are used only
 * by advanced developers.
 */

/*
 *  Function: LonQueryDomainConfig
 *  Request a copy of a local domain table record.
 *
 *  Parameters:
 *  index - index of requested domain table record (0, 1)
 *  pDomain - pointer to a <LonDomain> structure
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Call this function to request a copy of a local domain table record. 
 *  The information is returned via the <LonDomain> structure provided.
 */
const LonApiError LonQueryDomainConfig(const unsigned index,
                                       LonDomain* const pDomain)
{
	LonApiError sts = checkInit();
	if (LON_SUCCESS(sts))
	{
        LtDomainConfiguration dc;
        sts = LonSts(pMyStack->getDomainConfiguration(index, &dc));
        if (LON_SUCCESS(sts))
        {
            dc.toLonTalk((byte *)pDomain, LT_CLASSIC_DOMAIN_STYLE);
        }
    }
    else
        APIDebug("LonQueryDomainConfig = %d\n", sts);

    return sts;
}

/*
 *  Function: LonQueryNvConfig
 *  Request copy of NV configuration data.
 *
 *  Parameters:
 *  index - index of requested NV
 *  pNvConfig - pointer to a <LonNvEcsConfig> structure
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Call this function to request a copy of the local NV configuration data.
 *  The configuration will be stored in the <LonNvEcsConfig> structure
 *  provided.
 */
const LonApiError LonQueryNvConfig(const unsigned index,
                                   LonNvEcsConfig* const pNvConfig)
{
	LonApiError sts = checkInit();
	if (LON_SUCCESS(sts))
	{
        sts = pMyStack->queryNvConfig(index, pNvConfig);
    }
    else
        APIDebug("LonQueryNvConfig = %d\n", sts);
    return sts;
}

/*
 *  Function: LonQueryAliasConfig
 *  Request copy of alias configuration data.
 *
 *  Parameters:
 *  index - index of requested alias
 *  pAlias - - pointer to a <LonAliasEcsConfig> structure
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Call this function to request a copy of the alias configuration data.
 *  The configuration will be stored in the <LonAliasEcsConfig> structure
 *  provided. 
 */
const LonApiError LonQueryAliasConfig(const unsigned index,
                                      LonAliasEcsConfig* const pAlias)
{
	LonApiError sts = checkInit();
	if (LON_SUCCESS(sts))
	{
        sts = pMyStack->queryAliasConfig(index, pAlias);
	}
    else
        APIDebug("LonQueryAliasConfig = %d\n", sts);
    return sts;
}

/*
 *  Function: LonNvIsBound
 *  Determine whether or not a network variable is bound.
 *
 *  Parameters:
 *  index - index of the network avarible
 *  pIsBound - pointer to receive the "isBound" attribute
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Call this function to determine whether or not a network variable is bound.
 *  A network varible is bound if it, or any of its aliases has a bound 
 *  selector or and address table entry. The unbound selector for a given 
 *  network variable is equal to (0x3fff - nvIndex).  A network variable
 *  or alias has an address if the address index is anything other than 0xffff.
 */
const LonApiError LonNvIsBound(const unsigned index, LonBool* const pIsBound)
{
	LonApiError sts = checkInit();
    if (LON_SUCCESS(sts))
	{
        int arrayIndex;
        LtNetworkVariable *pNv = pMyStack->getNetworkVariable(index, arrayIndex);
        if (pNv == NULL)
        {
            sts = LonApiNvIndexInvalid;
        }
        else
        {
            *pIsBound = pMyStack->isBound(pNv, arrayIndex, ISBOUND_ANY);
        }
    }
    else
        APIDebug("LonNvIsBound = %d\n", sts);
    return sts;
}

/*
 *  Function: LonQueryAddressConfig
 *  Request copy of address table configuration data.
 *
 *  Parameters:
 *  index - index of requested address table entry
 *  pAddress - pointer to a <LonAddress> structure
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Call this function to request a copy of the address table configuration data.
 *  The configuration will be stored in the <LonAddress> structure
 *  provided. 
 */
const LonApiError LonQueryAddressConfig(const unsigned index,
                                        LonAddress* const pAddress)
{
	LonApiError sts = checkInit();
    if (LON_SUCCESS(sts))
	{
        sts = pMyStack->queryAddressConfig(index, pAddress);
    }
    else
        APIDebug("LonQueryAddressConfig = %d\n", sts);
    return sts;
}

/*
 *  Function: LonMtIsBound
 *  Determine whether or not a message tag is bound.
 *
 *  Parameters:
 *  tag - the message tag
 *  pIsBound - pointer to receive the "isBound" attribute
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Call this function to determine whether or not a message tag is bound.
 *  A message tag is bound if the associated address type is anything other
 *  than lonAddressUnassigned.
 */
const LonApiError LonMtIsBound(const unsigned tag, LonBool* const pIsBound)
{
	LonApiError sts = checkInit();
    if (LON_SUCCESS(sts))
	{
        if (tag >= (unsigned)pMyStack->getMessageTagCount())
        {
            sts = LonApiMsgInvalidMsgTag;
        }
        else
        {
            LonAddress address;
            sts = pMyStack->queryAddressConfig(tag, &address);
            if (LON_SUCCESS(sts))
	        {
                *pIsBound = (address.SubnetNode.Type != LonAddressUnassigned);
            }
        }
    }
    else
        APIDebug("LonMtIsBound = %d\n", sts);
    return sts;
}


/*
 *  Function: LonQueryConfigData
 *  Request copy of local configuration data.
 *
 *  Parameters:
 *  pConfig - pointer to a <LonConfigData> structure
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Call this function to request a copy of device's configuration data.
 *  The configuration will be stored in the <LonConfigData> structure
 *  provided. 
 */
const LonApiError LonQueryConfigData(LonConfigData* const pConfig)
{
	LonApiError sts = checkInit();
	if (LON_SUCCESS(sts))
	{
		sts = LonSts(pMyStack->getConfigurationData((byte *)pConfig, 0, 
													sizeof(LonConfigData)));
    }
    else
        APIDebug("LonQueryConfigData = %d\n", sts);
    return sts;
}

/*
 *  Function: LonQueryStatus
 *  Request local status and statistics.
 *
 *  Parameters:
 *  pStatus - pointer to a <LonStatus> structure.
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Call this function to obtain the local status and statistics of the IzoT 
 *  device. The status will be stored in the <LonStatus> structure provided. 
 */
const LonApiError LonQueryStatus(LonStatus* const pStatus)
{
    APIDebug("Start LonQueryStatus\n");
	LonApiError sts = checkInit();
	if (LON_SUCCESS(sts))
	{
        LtStatus status;
        sts = LonSts(pMyStack->retrieveStatus(status));
        if (LON_SUCCESS(sts))
        {
			LON_SET_UNSIGNED_WORD(pStatus->TransmitErrors, status.transmissionErrors);
			LON_SET_UNSIGNED_WORD(pStatus->TransactionTimeouts, status.transmitTimeouts);
			LON_SET_UNSIGNED_WORD(pStatus->ReceiveTransactionsFull, status.receiveTransactionFulls);
			LON_SET_UNSIGNED_WORD(pStatus->LostMessages, status.lostMessages);
			LON_SET_UNSIGNED_WORD(pStatus->MissedMessages, status.missedMessages);
			pStatus->ResetCause = (LON_ENUM(LonResetCause))status.resetCause;
			pStatus->NodeState = (LON_ENUM(LonNodeState))status.state;
			pStatus->VersionNumber = (LonByte)status.version;
			pStatus->ErrorLog = (LON_ENUM(LonSystemError))status.error;
			pStatus->ModelNumber = (LON_ENUM(LonNeuronModel))status.model;
        }
    }
    APIDebug("End LonQueryStatus = %d\n", sts);
    return sts;
}

/*
 *  Function: LonQueryTransceiverStatus
 *  Request local transceiver status information.
 *
 *  Parameters:
 *  pTransceiverParameters - pointer to a <LonTransceiverParameters> structure
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Call this function to query the status of the local IzoT Transceiver. 
 *  The parameters are stored in the <LonTransceiverParameters> structure
 *  provided.
 *
 *  Note that this function is provided only for compatibility with the ShortStack 
 *  LonTalk Compact API.  The transceiver status information is useful only for 
 *  transceivers supporting special purpose mode.  Because IzoT Device does not use a 
 *  special purpose mode transceiver, this function always returns 
 *  LonApiInvalidParameter.
 */
const LonApiError LonQueryTransceiverStatus(
    LonTransceiverParameters* const pTransceiverParameters)
{
    APIDebug("Start LonQueryTransceiverStatus\n");
	LonApiError sts = checkInit();
	if (LON_SUCCESS(sts))
	{
        byte data[LT_NUM_REGS];
        if (pMyStack->isSpecialPurpose()) 
	    {
            sts = LonSts(pMyStack->fetchXcvrReg(data, 0));
        } 
	    else 
	    {
		    sts = LonSts(LT_INVALID_PARAMETER);
        }

        if (LON_SUCCESS(sts))
        {
	        memcpy(pTransceiverParameters, data, sizeof(*pTransceiverParameters));
        }
    }
    APIDebug("End LonQueryTransceiverStatus = %d\n", sts);
    return sts;
}

/*
 *  Function: LonQueryReadOnlyData
 *  Request copy of local read-only data.
 *
 *  Parameters:
 *  pReadOnlyData - pointer to a <LonReadOnlyData> structure
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Call this function to request a copy of device's read-only data.
 *  The read-only data will be stored in the <LonReadOnlyData> structure
 *  provided. 
 */
const LonApiError LonQueryReadOnlyData(LonReadOnlyData* const pReadOnlyData)
{
    APIDebug("Start LonQueryReadOnlyData\n");
	LonApiError sts = checkInit();
	if (LON_SUCCESS(sts))
	{
        sts = LonSts(pMyStack->getReadOnlyData((byte *)pReadOnlyData));
    }
    APIDebug("End LonQueryReadOnlyData = %d\n", sts);
    return sts;
}

/*
 *  Function: LonSetNodeMode
 *  Sets the device's mode and/or state.
 *
 *  Parameters:
 *  mode - mode of the IzoT device, see <LonNodeMode>
 *  state - state of the IzoT device, see <LonNodeState>
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Remarks:
 *  Use this function to set the IzoT device's mode and state. 
 *  If the mode parameter is *LonChangeState*, then the state parameter may be 
 *  set to one of *LonApplicationUnconfig*, *LonNoApplicationUnconfig*, 
 *  *LonConfigOffLine* or *LonConfigOnLine*.  Otherwise the state parameter 
 *  should be *LonStateInvalid* (0).  Note that while the <LonNodeState> 
 *  enumeration is used to report both the state and the mode (see <LonStatus>), 
 *  it is *not* possible to change both the state and mode (online/offline) at 
 *  the same time.
 *
 *  You can also use the shorthand functions <LonGoOnline>, <LonGoOffline>, 
 *  <LonGoConfigured>, and <LonGoUnconfigured>.
 */
const LonApiError LonSetNodeMode(const LonNodeMode mode, 
								 const LonNodeState state)
{
    APIDebug("Start LonSetNodeMode\n");
	LonApiError sts = checkInit();
	if (LON_SUCCESS(sts))
	{
        boolean wasOffline = pMyStack->getOffline();
		switch(mode)
		{
		case LonApplicationOffLine:
		    pMyStack->setOffline(true);
            if (!wasOffline)
                LonOffline();
			break;
		case LonApplicationOnLine:
			pMyStack->setOffline(false);
            if (wasOffline)
                LonOnline();
			break;
		case LonApplicationReset:
			pMyStack->initiateReset();
			break;
		case LonChangeState:
			sts = LonSts(pMyStack->changeState(state));
			break;
		default:
			sts = LonApiInvalidParameter;
		}
    }
    APIDebug("End LonSetNodeMode = %d\n", sts);
    return sts;
}

/* 
 *  Function: LonUpdateAddressConfig
 *  Updates an address table record on the IzoT device.
 *
 *  Parameters:
 *  index - index of the address table to update
 *  pAddress - pointer to address table record 
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Remarks:
 *  Use this function to write a record to the local address table.
 */
const LonApiError LonUpdateAddressConfig(const unsigned index,
										 const LonAddress* const pAddress)
{
	LonApiError sts = checkInit();
	if (LON_SUCCESS(sts))
	{
        sts = pMyStack->updateAddressConfig(index, pAddress);
    }
    APIDebug("LonUpdateAddressConfig = %d\n", sts);
    return sts;
}

/* 
 *  Function: LonUpdateAliasConfig
 *  Updates an alias table record on the IzoT device.
 *
 *  Parameters:
 *  index - index of alias table record to be written
 *  pAlias - pointer to the alias table record
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  This function writes a record in the local alias table.
 *  This function is part of the optional network management update API (LON_NM_UPDATE_API).
 */
const LonApiError LonUpdateAliasConfig(const unsigned index, const LonAliasEcsConfig* const pAlias)
{
	LonApiError sts = checkInit();
	if (LON_SUCCESS(sts))
	{
        sts = pMyStack->updateAliasConfig(index, pAlias);
    }
    APIDebug("LonUpdateAliasConfig = %d\n", sts);
    return sts;
}

/* 
 *  Function: LonUpdateConfigData
 *  Updates the configuration data on the IzoT device.
 *
 *  Parameters:
 *  pConfig - pointer to <LonConfigData> configuration data
 *  
 *  Returns:
 *  <LonApiError>.
 *
 *  Remarks:
 *  Call this function to update the device's configuration data based on the 
 *  configuration stored in the <LonConfigData> structure.
 */
const LonApiError LonUpdateConfigData(const LonConfigData* const pConfig)
{
	LonApiError sts = checkInit();
	if (LON_SUCCESS(sts))
	{
        sts = pMyStack->updateConfigData(pConfig);
    }
    APIDebug("LonUpdateConfigData = %d\n", sts);
    return sts;
}

/*
 *  Function: LonUpdateNvConfig
 *  Updates a network variable configuration table record on the IzoT device.
 *
 *  Parameter:
 *  index - index of network variable
 *  pNvConfig - network variable configuration
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Remarks:
 *  This function can be used to update one record of the network variable
 *  configuration table.
 */
const LonApiError LonUpdateNvConfig(const unsigned index,
									const LonNvEcsConfig* const pNvConfig)
{
	LonApiError sts = checkInit();
	if (LON_SUCCESS(sts))
	{
        sts = pMyStack->updateNvConfig(index, pNvConfig);
    }
    APIDebug("LonUpdateNvConfig = %d\n", sts);
    return sts;
}

/* 
 *  Function:   LonUpdateDomainConfig
 *  Updates a domain table record on the IzoT device.
 *
 *  Parameters:
 *  index - the index of the domain table to update
 *  pDomain - pointer to the domain table record
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Remarks:
 *  This function can be used to update one record of the domain table.
 */
const LonApiError LonUpdateDomainConfig(const unsigned index,
										const LonDomain* const pDomain)
{
	LonApiError sts = checkInit();
	if (LON_SUCCESS(sts))
	{
        LtDomainConfiguration dc;
		int len;

#if PRODUCT_IS(IZOT)
		LontalkStackUriScheme chnlType = myDeviceUri.getScheme();
        LonDomain domain;
        memcpy(&domain, pDomain, sizeof(LonDomain)); 

        if (chnlType == IPNativeEnhanced)
        {
            // Check if the option bits are currently set to backward compatibility mode (all ones)
            // If so, we need to set/clear the bits accordingly
            LonBool isBackCompatibility = (LON_GET_ATTRIBUTE(domain, LON_DOMAIN_OPTION_BITS) == 0x0F); 
            if (isBackCompatibility)
            {
                // Currently set as compatibility mode, clear the OMA and DHCP
                LON_SET_ATTRIBUTE(domain,LON_DOMAIN_OMA, 0);    // clear OMA 
                LON_SET_ATTRIBUTE(domain,LON_DOMAIN_DHCP, 0);   // clear DHCP 
            }
            LON_SET_ATTRIBUTE(domain,LON_DOMAIN_LS_ENHANCED_MODE, 1);  // set the LT/IP Enhanced Mode bit
        }
        dc.fromLonTalk((byte *)&domain, len, LT_CLASSIC_DOMAIN_STYLE);
#else
		dc.fromLonTalk((byte *)pDomain, len, LT_CLASSIC_DOMAIN_STYLE);
#endif

        APIDebug("Index=%d Subnet=%d Node=%d IsClone=%d IsFlexDomain:%d UseLsEnhancedMode=%d UseOMA=%d DIDLength:%d DID: %02x %02x %02x %02x %02x %02x\n",
            index,dc.getSubnet(), dc.getNode(), dc.isClone(), dc.isFlexDomain(), dc.getUseLsEnhancedMode(), dc.getUseOma(),
            dc.getDomain().getLength(), dc.getDomain().getData(0), dc.getDomain().getData(1),
            dc.getDomain().getData(2), dc.getDomain().getData(3), dc.getDomain().getData(4),
            dc.getDomain().getData(5));

        sts = LonSts(pMyStack->updateDomainConfiguration(index, &dc, true, false));
	}
    APIDebug("LonUpdateDomainConfig(index = %d) = %d\n", index, sts);
    return sts;
}

/* 
 *  Function: LonClearStatus
 *  Clears the statistics 
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Remarks:
 *  This function can be used to clear the IzoT device status and statistics 
 *  records.
 */
const LonApiError LonClearStatus(void)
{
	LonApiError sts = checkInit();
	if (LON_SUCCESS(sts))
	{
        sts = LonSts(pMyStack->clearStatus());
    }
    APIDebug("LonClearStatus = %d\n", sts);
    return sts;
}

/*
 *  Function: LonNvdAppSegmentHasBeenUpdated
 *  Informs the IzoT stack that the application data segment has been updated.  
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Use this function to use this function to inform that IzoT stack that some data 
 *  been updated that should be written out to the indicated non-volatile data 
 *  segment.  The IzoT Stack will schedule a write to the data segment after the
 *  guardBand timeout has expired.  
 *    This function is part of the non-volatile data API.
 */
FTXL_EXTERNAL_FN const LonApiError LonNvdAppSegmentHasBeenUpdated(void)
{
	LonApiError sts = checkInit();
	if (LON_SUCCESS(sts))
	{
		sts = pMyStack->applSegmentHasBeenUpdated();
	}
    APIDebug("LonNvdAppSegmentHasBeenUpdated = %d\n", sts);
	return sts;
}

/*
 *  Function: LonNvdFlushData
 *  Flush all non-volatile data out to persistent storage.  
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Remarks:
 *  This function may be called by the application task to block until all 
 *  non-volatile data writes have been completed.  The application might do 
 *  this, for example, in response to a <LonNvdStarvation> event.
 */
FTXL_EXTERNAL_FN const LonApiError LonNvdFlushData(void)
{
	LonApiError sts = checkInit();
	if (LON_SUCCESS(sts))
	{
		sts = pMyStack->flushNvd();
	}
    APIDebug("LonNvdFlushData = %d\n", sts);
	return sts;
}

/*
 *  Function: LonNvdGetMaxSize
 *  Gets the number of bytes required to store persistence data
 *
 *  Parameters:
 *  segmentType - The segment type, see <LonNvdSegmentType>
 *
 *  Returns:
 *  The number of bytes required to store peristence data for the specified 
 *  segment.
 *
 *    This function is part of the non-volatile data API.
 */
FTXL_EXTERNAL_FN const int LonNvdGetMaxSize(LonNvdSegmentType segmentType)
{
	int size = 0;
	if (LON_SUCCESS(checkCreated()))
	{
        size = pMyStack->nvdGetMaxSize(segmentType);
    }
    APIDebug("LonNvdGetMaxSize = %d, size = %d\n", LonApiNoError, size);
	return size;
}


/*
 *  Function: LonRegisterUniqueId
 *  Registers the unique ID (Neuron ID).
 *
 *  Parameters:
 *  pId   - pointer to the the unique ID
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Remarks:
 *  The IzoT application must register a value unique ID prior to calling LonLidCreateStack.
 *  The stack will create a random unique ID if there is no unique ID registered prior 
 *  to calling LonLidCreateStack. 
 *
 *  The *Unique ID* is also known as the *Neuron ID*, however, *Neuron ID* is 
 *  a deprecated term. 
 */
FTXL_EXTERNAL_FN const LonApiError LonRegisterUniqueId(const LonUniqueId* const pId)
{
    LtUniqueId myUniqueId;
    LtUniqueIdText textUid;
    LonApiError sts = LonApiNoError;

    if (pId != null)
    {
        myUniqueId = *pId;
    }

    LtPlatform::setUniqueId(myUniqueId);
    APIDebug("LonRegisterUniqueId = %s\n", myUniqueId.toText(textUid));
    return sts;
}

/*
 *  Function: LonGetUniqueId
 *  Gets the register unique ID (Neuron ID).
 *
 *  Parameters:
 *  pId   - pointer to the the unique ID
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Remarks:
 *  The IzoT application must register a value unique ID prior to calling LonLidCreateStack.
 *  The stack will create a random unique ID if there is no unique ID registered prior to 
 *  calling LonLidCreateStack. 
 *
 *  The *Unique ID* is also known as the *Neuron ID*, however, *Neuron ID* is 
 *  a deprecated term. 
 */
FTXL_EXTERNAL_FN const LonApiError LonGetUniqueId(LonUniqueId* pId)
{
    LonApiError sts = LonApiNoError;

    if (pId == NULL)
    {
        sts = LonApiInitializationFailure;
    }

    if (LON_SUCCESS(sts))
    {
        LtUniqueId uid;
        LtUniqueIdText textUid;

        LtPlatform::getUniqueId(&uid);
        memcpy(pId, uid.getData(), sizeof(LonUniqueId));
        APIDebug("LonGetUniqueId = %s\n", uid.toText(textUid));
    }
    if (!LON_SUCCESS(sts))
        APIDebug("LonGetUniqueId = %d\n", sts);
    return sts;
}

#if FEATURE_INCLUDED(IP852)
/*
 *  Function: LonGetPersistentUniqueID
 *  Gets the unique ID that is currently saved in the persistent(nvd) file.  This only applies for IP-852 interface.
 *  When the IzoT stack object is created via the <LonLidCreateStack> the ID that is unique for each IP-852 device
 *  is saved into a persistent file located in the folder specified in <LonSetNvdFsPath>.    
 *  It returns a zero unique ID if there is none.
 *       
 *  Parameters:
 *  pId - pointer to the buffer to hold the unique ID
 *  
 *  Returns:
 *  <LonApiError>.
 * 
 *  Remarks:
 *   
 */ 
FTXL_EXTERNAL_FN const LonApiError LonGetPersistentUniqueID(LonUniqueId* pId)
{
    LonApiError sts = LonApiNoError;
    LtPersistence persistence(0);
    persistence.setType(LonNvdSegUniqueId);

    LtUniqueId uid;
    LtUniqueIdText textUid;

    if (persistence.readUniqueID(&uid) == LT_PERSISTENCE_OK)
    {
        memcpy(pId, uid.getData(), sizeof(LonUniqueId));
        APIDebug("LonGetPersistentUniqueID = %s\n", uid.toText(textUid));
    }
    else
    {
        memset(pId, 0, sizeof(LonUniqueId));
        APIDebug("LonGetPersistentUniqueID = none\n");
    }
    return sts;
}


#endif

/*
 *  Function: LonGetNvdFsPath
 *  This function is used by the <LonLidCreateStack> and the default implementation of NVD (non-volatile data) callbacks 
 *  <LonNvdOpenForRead>, <LonNvdOpenForWrite>, <LonNvdDelete>, <LonNvdIsInTransaction>,
 *  <LonNvdEnterTransaction> and <LonNvdExitTransaction> to determine the location of the 
 *  non-volatile data folder/path.
 *
 *  Parameters:
 *  pFsPath - Pointer to the buffer to hold the non-volatile data folder/path
 *  maxLength - size of the buffer
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Remarks:
 *  It returns a default non-volatile data if the path has not been set. You need to call <LonSetNvdFsPath>
 *  to set the non-volatile data path. 
 *
 */
FTXL_EXTERNAL_FN const LonApiError LonGetNvdFsPath(char* pFsPath, int maxLength)
{
    LonApiError sts = LonApiNoError;

    if (pFsPath == NULL)
    {
        sts = LonApiInitializationFailure;
    }

    if (LON_SUCCESS(sts))
    {
        LtPlatform::getPersistPath(pFsPath, maxLength);
        APIDebug("End LonGetNvdFsPath = %s\n", pFsPath);
    }
    else
        APIDebug("End LonGetNvdFsPath = %d \n", sts);
    return sts;
}

/*
 *  Function: LonSetNvdFsPath
 *  Sets the non-volatile data folder. This API must be called before the create stack <LonLidCreateStack>
 *  
 *  Parameters:
 *  pFsPath - the path to save the non-volatile data
 *
 *  Returns:
 *  <LonApiError>.
 *
 */
FTXL_EXTERNAL_FN const LonApiError LonSetNvdFsPath(const char* pFsPath)
{
    LonApiError sts = checkCreated();
    if (LON_SUCCESS(sts))
    {
        // This API must be called before the stack is created
        sts = LonApiNotAllowed;
    }
    else
    {
        LtPlatform::setPersistPath(pFsPath);    
        sts = LonApiNoError;
    }
    APIDebug("LonSetNvdFsPath = %d NVDPath = %s\n", sts, pFsPath);
    return sts;
}

/*
 *  Function: LonResetPersistence
 *  Remove the persistence data files. This API must be called before the create stack <LonLidCreateStack>
 *  
 *  Parameters:
 *  resetType - See the PersistenceResetType for different types of reset
 *
 *  Returns:
 *  <LonApiError>.
 *
 */
FTXL_EXTERNAL_FN const LonApiError LonResetPersistence(PersistenceResetType resetType)
{
    LonApiError sts = checkCreated();
#if !PERSISTENCE_TYPE_IS(FTXL)
    sts = LonApiNotAllowed;
#endif

    if (LON_SUCCESS(sts))
    {
        // This API must be called before the stack is created or persistence type is not FTXL
        sts = LonApiNotAllowed;
    }
    else
    {
        // Update the flag that the persitence files has been reset */
        LtPersistence::setResetFlag(TRUE);

        for (int i = 0; i < (int)LonNvdSegNumSegmentTypes; ++i)
        {
            if ((i == (int)LonNvdSegUniqueId) && (resetType == PersistenceResetPreserveUniqueId))
            {
                continue;
            }
            LonNvdDelete((LonNvdSegmentType)i);
        }
        sts = LonApiNoError;
    }
    APIDebug("LonResetPersistence = %d ResetType = %d\n", sts, resetType);
    return sts;
}


#if PRODUCT_IS(IZOT)
/*
 *  Function: LonGetDeviceUri
 *  Returns the Device URI used to create the stack.
 *
 *  Parameters:
 *  pDeviceURI - Pointer to the buffer to hold the device URI
 *     scheme://[addr1][,addr2][:port]
 *     scheme = {uc|izot|izot-e}
 *        (default: izot)
 *         uc = IP-852 unicast
 *         izot= LS/IP
 *         izot-e= LS/IP in enhanced mode
 *     IP-852 Unicast:
 *       scheme = uc
 *       addr1 = local listening address (default: 0.0.0.0 = ANY_ADDR)
 *       addr2 = not used (error)
 *       port  = local listening port (default: 1628)
 *     LS/IP:
 *         scheme = izot/izot-e
 *         addr1 = device name (only used in Windows environment)
 *         addr2 = interface name, linux: "eth" or "wlan" for wifi (default: eth)
 *                  windows: "Local Area Connection" or "Wireless Network Connection"
 *         options = 0 (see LtUriOptions in LtUri.h)
 *         port  = only 2541 is a valid port
 *
 *  maxLength - size of the buffer
 *
 *  Returns:
 *  <LonApiError>.
 *
 *  Remarks:
 *
 */
FTXL_EXTERNAL_FN const LonApiError LonGetDeviceUri(char* pDeviceURI, int maxLength)
{
    LonApiError sts = LonApiNoError;

    if (pDeviceURI == NULL)
    {
        sts = LonApiInitializationFailure;
    }

    if (LON_SUCCESS(sts))
    {
        myDeviceUri.getData(pDeviceURI, maxLength);
        APIDebug("LonGetDeviceUri = %s\n", pDeviceURI);
    }
    else
        APIDebug("LonGetDeviceUri = %d \n", sts);
    return sts;
}

/*
 *  Function: LonSetDeviceUri
 *  Sets the device URI.  This API must be called before the create stack <LonLidCreateStack>
 *  
 *  Parameters:
 *  pDeviceURI - Pointer to device URI
 *     scheme://[addr1][,addr2][:port]
 *
 *  scheme = {ldv|unicast|multicast} (default: multicast)    (aliases: uc=unicast, mc=multicast)
 *
 *  unicast:
 *    addr1 = local listening address (default: 0.0.0.0 = ANY_ADDR)
 *    addr2 = not used (error)
 *    port  = local listening port (default: 1628)
 *
 *  multicast:
 *    addr1 = local listening address (default: 0.0.0.0 = ANY_ADDR)
 *    addr2 = multicast group address (default: 239.192.84.76)
 *    port  = multicast group port (default: 1628)
 *
 *  ldv:
 *    addr1 = LDV device name (default: "LON1")
 *    addr2 = not used (error)
 *    port  = not used (error)
 *
 * e.g.
 *
 * "" = multicast with default group and port
 *
 * ldv://
 * uc://
 * mc://
 *
 * ldv://LON2
 * uc://:1640
 * mc://:1629
 * mc://,225.0.34.57
 * mc://,225.0.34.18:1630
 *
 * uc://192.168.0.10
 * uc://192.168.0.10:1640
 * mc://192.168.0.10:1629
 * mc://192.168.0.10,225.0.34.57
 * mc://192.168.0.10,225.0.34.18:1630

 *  Returns:
 *  <LonApiError>.
 *
 */
FTXL_EXTERNAL_FN const LonApiError LonSetDeviceUri(const char* pDeviceURI)
{
    LonApiError sts = checkCreated();
    if (LON_SUCCESS(sts))
    {
        // This API must be called before the stack is created
        sts = LonApiNotAllowed;
    }
    else
    {
        if (myDeviceUri.setData(pDeviceURI))
        {
            char szURI[MAX_URI_LEN];
            myDeviceUri.getData(szURI, MAX_URI_LEN);
            sts = LonApiNoError;
            APIDebug("Device URI = \"%s\"\n", szURI);
        }
        else
            sts = LonInvalidDeviceURI;    
    }
    APIDebug("LonSetDeviceUri = %d Device Uri = %s\n", sts, pDeviceURI);
    return sts;
}

#endif

/*
 *  Function: LonSetTracefile
 *  Sets the filename to use for the trace logging.  When the pFilename is NULL, trace logging stops and a previously opened 
 *  tracefile is closed. 
 *  
 *  Parameters:
 *  pFilename - the filename for the trace logging
 *  append    - if it is set to true, it means to open file for writing at the end of the file (appending) without removing the EOF marker
 *              before writing new data to the file; creates the file first if it doesn't exist.
 *              if it is set to false, it means to open an empty trace file for writing. If the given file exists, 
 *              its contents are destroyed.
 *
 *  Returns:     
 *  none 
 *
 */
FTXL_EXTERNAL_FN void LonSetTracefile(const char* pFilename, LonBool append)
{
    // close the previous trace log (if exists)
    if (fpTracefile != NULL)
    {
        fclose(fpTracefile);
        fpTracefile = NULL;
    }
    if (pFilename != NULL)
    {
        const char *openStr = append ? "a" : "w";
        fpTracefile = fopen(pFilename, openStr);
        if (fpTracefile != NULL && append)
        {	// insert a separator
        	fprintf(fpTracefile, "\n\n\t===\n\n");
        }
    }
}

/*
 *  Function: LonGetAppSignature
 *  Gets the application's signature
 *  
 *  Returns:     
 *  The application signature which was sepcified by the application 
 *  when the stack is created (<LonLidCreateStack>).
 */
FTXL_EXTERNAL_FN unsigned LonGetAppSignature()
{
    unsigned signature = 0; 
    LonApiError sts = checkCreated();

    if (LON_SUCCESS(sts))
        signature = pMyStack->getAppSignature();

    APIDebug("LonGetAppSignature = %d Signature = 0x%x\n", sts, signature);
    return signature;
}

/*
 *  Function: LonGetAliasCount
 *  Gets the size of the alias table
 *  
 *  Returns:     
 *  The size of the alias table which is specified by the application 
 *  when the stack is created (<LonLidCreateStack>).
 */
FTXL_EXTERNAL_FN unsigned LonGetAliasCount()
{
    unsigned aliasCount = 0; 
    LonApiError sts = checkCreated();

    if (LON_SUCCESS(sts))
        aliasCount = pMyStack->getAliasCount();

    APIDebug("LonGetAliasCount = %d Count = %d\n", sts, aliasCount);
    return aliasCount;
}

/*
 *  Function: LonGetAddressTableCount
 *  Gets the size of the address table
 *  
 *  Returns:     
 *  The size of the address table which is specified by the application 
 *  when the stack is created (<LonLidCreateStack>).
 */
FTXL_EXTERNAL_FN unsigned LonGetAddressTableCount()
{
    unsigned addrTableCount = 0; 
    LonApiError sts = checkCreated();

    if (LON_SUCCESS(sts))
        addrTableCount = pMyStack->getAddressTableCount();

    APIDebug("LonGetAddrTableCount = %d Count = %d\n", sts, addrTableCount);
    return addrTableCount;
}

/*
 *  Function: LonGetStaticNVCount
 *  Gets the size of the address table
 *  
 *  Returns:     
 *  The number of static network variable specified by the application 
 *  when the stack is created (<LonLidCreateStack>).
 */
FTXL_EXTERNAL_FN unsigned LonGetStaticNVCount()
{
    unsigned staticNVCount = 0; 
    LonApiError sts = checkCreated();

    if (LON_SUCCESS(sts))
        staticNVCount = pMyStack->getStaticNetworkVariableCount();

    APIDebug("LonGetStaticNVCount = %d Count = %d\n", sts, staticNVCount);
    return staticNVCount;
}

#if FEATURE_INCLUDED(IP852)
/*
 *  Function: LonIsFirstRun
 *  Determine whether or not an application is running for the first time
 *  
 *  Returns:     
 *  True if this is the first time the application is running with the same
 *  setup and configuration.
 *  You can depend on this information if you need to preset certain
 *  values only when the first time the application is running.
 */
FTXL_EXTERNAL_FN const LonApiError LonIsFirstRun(LonBool* const pIsFirstRun)
{
	LonApiError sts = checkCreated();
	*pIsFirstRun = true;
    if (LON_SUCCESS(sts))
	{		
		*pIsFirstRun = LtPlatform::getIsFirstRun();
		APIDebug("End LonIsFirstRun = %s \n", *pIsFirstRun ? "TRUE" : "FALSE");
	}
	else
		APIDebug("End LonIsFirstRun - Error = %d\n", sts);
    return sts;
}
#endif

/*
 *  Function: LonGetSIDataLength
 *  Computes the length of the version 1 SI data
 *  
 *  Returns: 
 *  The SI data length in bytes
 *
 *  Remarks:  
 *  This function is used to find out how big the data buffer needs to be allocated for the SI data.
 */
FTXL_EXTERNAL_FN const int LonGetSIDataLength()
{
    int dataLength = 0;
    LonApiError sts = checkCreated();

    if (LON_SUCCESS(sts))
    {
       dataLength =  pMyStack->getSiDataLength();
       APIDebug("End LonGetSIDataLength - Length = %d\n", dataLength);
    }
    else
        APIDebug("End LonGetSIDataLength - Error = %d\n", sts);
    return dataLength;
}

/*
 *  Function: LonGetSIData
 *  Gets the SI data  
 *  
 *  Parameters:
 *  pSIData - pointer to the begining of SI data
 *  dataLen - the length of bytes pointed to by pSIData
 *
 *  Returns:  
 *      LonApiNoError - success
 *      LonApiNotInitialized - stack has not been created/initialized (<LonLidCreateStack>
 *      LonApiNotAllowed - pSIData buffer is too small.
 *
 *  Remarks:
 *  Use <LonGetSIDataLength> to find out the SI data length prior to calling this routine.
 *
 */
FTXL_EXTERNAL_FN const LonApiError LonGetSIData(LonByte* pSIData, const int dataLen)
{
    APIDebug("Start LonGetSIData\n");
    LonApiError sts = checkCreated();

    if (LON_SUCCESS(sts))
    {
        if ((pSIData == NULL) || (dataLen < pMyStack->getSiDataLength()))
        {
            sts = LonApiNotAllowed; // Buffer is too small
        }
        else
        {
            int SIDataLen;
            byte *pData = pMyStack->getSiData(&SIDataLen);

            if (SIDataLen == 0)
                sts = LonApiNotAllowed;     // Value out of range
            else
            {
		        APIDebug("End LonGetSIData. Length = %d\n", SIDataLen);
                memcpy(pSIData, pData, SIDataLen); 
                for (int i = 0; i < SIDataLen; i++)
                {
                    APIDebug("%02X ", *pData);
                    if (((i+1) % 8) == 0)
                        APIDebug("    ");
                    else
                    if (((i+1) % 16) == 0)
                        APIDebug("\n");
                    ++pData;
                }
                APIDebug("\n");
            }
        }
	}

    if (!LON_SUCCESS(sts))
		APIDebug("End LonGetSIData - Error = %d\n", sts);
    return sts;
}

#if defined(IZOT_PLATFORM)
/*
 *  Function: LonGetDidFromLocalAddress
 *  Gets the domain, subnet and node ID from the local IP address.
 *  The first two bytes of the IP address represent the LONTalk services domain ID,
 *  the third byte represents the LONTalk services subnet and the fourth byte
 *  represents the LONTalk services node ID.
 *  
 *  Parameters:
 *  pDomId - pointer to the domain Id
 *  domLength - the length of domain Id
 *  subnetID - subnet Id
 *  nodeID - node Id
 *
 *  Returns:  
 *      LonApiNoError - success
 *      LonApiNoIpAddress - can't retrieve Did from the local IP Address
 *
 */
FTXL_EXTERNAL_FN const LonApiError LonGetDidFromLocalAddress(LonByte* pDomId, unsigned* domLength, unsigned* subnetID, unsigned* nodeID)
{
    LonApiError sts = LonApiNoIpAddress;

    if (pChannel != NULL)
    {
		LontalkStackUriScheme chnlType;
#if PRODUCT_IS(IZOT)
		chnlType = myDeviceUri.getScheme();
#elif FEATURE_INCLUDED(IP852)
		chnlType = IPUnicast;
#else
		chnlType = Ldv;
#endif
		if (chnlType == IPNative || chnlType == IPNativeEnhanced)
		{
			LtDomain domain;
			LonByte currentIzoTIpAddr[16];
			int currentIzoTIpAddrLen = 0;

			// Query the IP address that this device would use when sending a message with
			// the specified source address
			// This will be used for ISI to determine the default domain and subnet/node Id
			memset(&domain, 0, sizeof(LtDomain));
			memset(currentIzoTIpAddr, 0, sizeof(currentIzoTIpAddr));
			currentIzoTIpAddrLen = ((LtLtLogicalChannel *)pChannel)->queryIpAddr(domain, 0, 0,
    			(LonByte *)&currentIzoTIpAddr);
			if (currentIzoTIpAddrLen > 0)
			{
				uint8_t len, subnet, node;

				ipv6_subnet_from_ls_prefix(pDomId, &len, &subnet, &node, (uint8_t *)currentIzoTIpAddr);
				*domLength = len;
				*subnetID = subnet;
				*nodeID = node;
				APIDebug("LonGetDidFromLocalAddress Domain len = %d subnet = %d nodeId = %d\n",
              		len, subnet, node);
				sts = LonApiNoError;
			}
		}
    }

    if (sts == LonApiNoIpAddress)
        APIDebug("LonGetDidFromLocalAddress = IP address has not been configured or not supported\n");

    return sts;
}
#endif


/******************************************************************************
 * Event Handler Default Implementation Functions
 ******************************************************************************/

/*
 *  Function: GetDefaultCurrentNvSize
 *  Gets the current size of a network variable.
 *
 *  Parameters:
 *  index - the index of the network variable
 *
 *  Returns:     
 *  Current size of the network variable as defined in the Neuron C 
 *  model file.  Zero if the network variable corresponding to index doesn't 
 *  exist.
 *
 *  Note that this is an internal function which called from the LonGetCurrentNvSize()if the callback vector 
 *  is not registered. 
 */
const unsigned GetDefaultCurrentNvSize(const unsigned index)
{
    int size = 0;
    LonApiError sts = checkCreated();
    if (LON_SUCCESS(sts))
    {
        size = pMyStack->getCurrentNvSize(index);
    }
    APIDebug("GetDefaultCurrentNvSize(Index %d) = %d Size = %d\n", index, sts, size);
    return size;
}

/*
 *  Function: GetDefaultApplicationSegmentSize
 *  Gets the current the application's segment size.  It is the sum of the declared size of all NV 
 *  with the LON_NV_CONFIG_CLASS flag set.
 *
 *  Parameters:
 *    none
 *
 *  Returns:     
 *  The application segment size which is the sum of the declared size of all NV with 
 *  the LON_NV_CONFIG_CLASS flag set. 
 *
 *  Note this is an internal function which called from the LonNvdGetApplicationSegmentSize()
 *  if the callback vector is not registered. 
 */
const unsigned GetDefaultApplicationSegmentSize()
{
    unsigned nonVolatileNvData = 0;

    LonApiError sts = checkCreated();
    if (LON_SUCCESS(sts))
    {
        nonVolatileNvData = pMyStack->getDefaultApplicationSegmentSize();
    }
    APIDebug("GetDefaultApplicationSegmentSize = %d Size = %d\n", sts, nonVolatileNvData);
    return nonVolatileNvData;
}

/*
 * Function: DefaultSerializeSegment
 * This is an internal function, used by the <LonNvdSerializeSegment>
 * and <LonNvdDeserializeSegment> callback functions.
 */
const LonApiError DefaultSerializeSegment(LonBool toNvMemory, void* const pData, const size_t size)
{
    LonApiError sts = checkCreated();
    if (LON_SUCCESS(sts))
    {
        pMyStack->defaultSerializeSegment(toNvMemory, pData, size);
    }
    APIDebug("DefaultSerializeSegment = %d\n", sts);
    return sts;
}













