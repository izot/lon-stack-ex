/*
 * File: FtxlTypes.h
 * Title: IzoT Device Stack 1.0 API Reference
 *
 * $Revision: #9 $
 *
 * Copyright Â© 2022 Dialog Semiconductor
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in 
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 * Abstract:
 * This file declares the enumerations and data types for the API. 
 * This file is part of the IzoT Device Stack 1.0 API.
 *
 */

#ifndef _FTXL_TYPES_H
#define _FTXL_TYPES_H

/*
 * Note this file is best included through FtxlDev.h, which is generated by the 
 * LonTalk Interface Developer. 
 */
#ifndef _LON_PLATFORM_H
#   error You must include LonPlatform.h first (prefer including FtxlDev.h)
#endif  /* _LON_PLATFORM_H */

/*
 * Note this file is best included through FtxlDev.h, which is generated by the 
 * LonTalk Interface Developer. 
 */
#ifndef _FTXL_API_H
#   error You must include FtxlApi.h first
#endif  /*  _FTXL_API_H */

/*
 * *****************************************************************************
 * SECTION: ERROR CODES
 * *****************************************************************************
 *
 * This section details the enumerations for error codes that this API can 
 * issue.  This section also lists the errors reported by the IzoT device in 
 * its error log (see <LonStatus>).
 */

/*
 * Enumeration: LonSystemError 
 * System and IzoT protocol stack error codes logged in the IzoT 
 * protocol stack's error log.
 * 
 * The codes can be accessed using the Query Status standard network management 
 * command.  
 * 
 * The standard system errors range above value 128. Values between 1 and 128 
 * are application-specific (but serious) errors. Values used by the IzoT 
 * protocol stack are also included in the <LonSystemError> enumeration. 
 *
 * The standard system error codes are discussed in the Smart Transceiver 
 * literature and in the CEA/EIA 709.1-B protocol specification.
 *
 */
typedef LON_ENUM_BEGIN(LonSystemError) 
{
    /*   0 */    LonNoError                 = 0,
    /*
     * IzoT specific system error codes
     */

    /* none */

    /*
     * Standard system error codes
     */
    /* 129 */    LonBadEvent            = 129u,
    /* 130 */    LonNvLengthMismatch    = 130u,
    /* 131 */    LonNvMsgTooShort       = 131u,
    /* 132 */    LonEepromWriteFail     = 132u,
    /* 133 */    LonBadAddressType      = 133u,
    /* 134 */    LonPreemptionModeTimeout = 134u,
    /* 135 */    LonAlreadyPreempted    = 135u,
    /* 136 */    LonSyncNvUpdateLost    = 136u,
    /* 137 */    LonInvalidRespAlloc    = 137u,
    /* 138 */    LonInvalidDomain       = 138u,
    /* 139 */    LonReadPastEndOfMsg    = 139u,
    /* 140 */    LonWritePastEndOfMsg   = 140u,
    /* 141 */    LonInvalidAddrTableIndex = 141u,
    /* 142 */    LonIncompleteMsg       = 142u,
    /* 143 */    LonNvUpdateOnOutputNv  = 143u,
    /* 144 */    LonNoMsgAvail          = 144u,
    /* 145 */    LonIllegalSend         = 145u,
    /* 146 */    LonUnknownPdu          = 146u,
    /* 147 */    LonInvalidNvIndex      = 147u,
    /* 148 */    LonDivideByZero        = 148u,
    /* 149 */    LonInvalidApplError    = 149u,
    /* 150 */    LonMemoryAllocFailure  = 150u,
    /* 151 */    LonWritePastEndOfNetBuffer = 151u,
    /* 152 */    LonApplCheckSumError   = 152u,
    /* 153 */    LonCnfgCheckSumError   = 153u, 
    /* 154 */    LonInvalidXcvrRegAddr  = 154u,
    /* 155 */    LonXcvrRegTimeout      = 155u,
    /* 156 */    LonWritePastEndOfApplBuffer = 156u,
    /* 157 */    LonIoReady             = 157u,
    /* 158 */    LonSelfTestFailed      = 158u,
    /* 159 */    LonSubnetRouter        = 159u,
    /* 160 */    LonAuthenticationMismatch  = 160u,
    /* 161 */    LonSeltInstSemaphoreSet    = 161u,
    /* 162 */    LonReadWriteSemaphoreSet   = 162u,
    /* 163 */    LonApplSignatureBad    = 163u,
    /* 164 */    LonRouterFirmwareVersionMismatch = 164
} LON_ENUM_END(LonSystemError);

/*
 * Enumeration: LonApiError
 * IzoT Device Stack 1.0 API error codes.
 *
 * This enumeration contains all IzoT Device Stack 1.0 API error codes, including the 
 * code for success _LonApiNoError_. Use the <LON_SUCCESS> macro to determine 
 * successful completion of an API function.
 *
 */
typedef LON_ENUM_BEGIN(LonApiError) 
{
    /*    0    */    LonApiNoError = 0,         /* no error. Use the LON_SUCCESS macro to test for this condition */
    /*
     * API errors related to network variables
     */
    /*    1    */    LonApiNvIndexInvalid =1,   /* invalid NV index */
    /*    2    */    LonApiNvLengthMismatch,    /* assumed length is not equal to actual length */
    /*    3    */    LonApiNvLengthTooLong,     /* NV data is too long */
    /*    4    */    LonApiNvPollNotPolledNv,   /* polling input NV requires declaration of polled attribute in the model file */
    /*    5    */    LonApiNvPollOutputNv,      /* cannot poll output network variable */
    /*    6    */    LonApiNvPropagateInputNv,  /* cannot propagate input network variable */    
    /*    7    */    LonApiNvPropagatePolledNv, /* cannot propagate a polled network variable */

    /*
     * API errors related to application messages
     */
    /*    11   */    LonApiMsgExplicitAddrMissing = 11, /* explicit destination required but missing */
    /*    12   */    LonApiMsgInvalidMsgTag,    /* invalid message tag provided */
    /*    13   */    LonApiMsgLengthTooLong,    /* message data exceeds limits */
    /*    14   */    LonApiMsgNotRequest,       /* message should be sent as a request */
    /*    15   */    LonApiMsgInvalidCode,      /* invalid message code */
    /*    16   */    LonApiMsgInvalidCorrelator, /* Invalid <LonCorrelator> */
    /*    17   */    LonApiMsgInvalidAddress,   /* Invalid address */
    /*
     * API errors related to the ShortStack serial or IzoT parallel driver
     */
    /*    31   */    LonApiTxBufIsFull              = 31,   /* no transmit (downlink) buffer available */
    /*    32   */    LonApiRxMsgNotAvailable,               /* no message has been received from the Micro Server */    
    /*    33   */    LonApiMicroServerUnresponsive,         /* the Micro Server is not responding to RTS */    
    /*
     * General API errors 
     */
    /*    41   */    LonApiVersionNotAvailable    = 41, /* Link-layer protocol version information unavailable */
    /*    42   */    LonApiNeuronIdNotAvailable,    /* Unique ID (Neuron ID) unavailable */
    /*    43   */    LonApiInitializationFailure,   /* Initialization failed */
    /*    44   */    LonApiIndexInvalid,            /* invalid index (for NV indices, see LonApiNvIndexInvalid) */
    /*    45   */    LonApiMessageNotAvailable,     /* invalid index (for NV indices, see LonApiNvIndexInvalid) */
    /*    46   */    LonApiNotInitialized,          /* API is not currently initialized.  Call <LonInit>. */
    /*    47   */    LonApiVersionNotSupported,     /* Structure version not supported. */
    /*    48   */    LonApiNotAllowed,              /* Operation not allowed */
    /*    49   */    LonApiInvalidParameter,        /* Invalid parameter specified */
    /*    50   */    LonApiOffline,                 /* Operation not allowed while device is offline. */
    /*    51   */    LonApiCallbackNotRegistered,   /* Callback function has not been registered. */
    /*    52   */    LonApiCallbackExceptionError,  /* An exception when executing the callback function.  */
    /*
     * Non-Volatile Data errors (IzoT only).  Returned by NVD callback functions.
     */
    /*    71   */   LonApiInvalidSegmentType   = 71, /* Not a supported NVD segment type. */
    /*    72   */   LonApiNvdFailure,                /* Generic non-volatile data failure. */
    /*    73   */   LonApiNvdSizeNotSupported,       /* Non-volatile data size is not supported. */
    /*    74   */   LonApiNvdFileError,              /* Non-volatile data access error. */
    /*
     * Direct Memory File (DMF) access errors.
     */
    /*    81   */   LonApiDmfOutOfRange         = 81, /* DMF address + count is out of range for operation. */
    /*    82   */   LonApiDmfReadOnly           = 82, /* Write to read-only DMF area. */
    /*    83   */   LonApiDmfNoDriver           = 83, /* No DMF driver defined. */

    /*    90   */   LonApiNoNetworkInterface     = 90, /* No Network Interface defined. See LonGetMyNetworkInterface in FtxlHandlers.c */
    /*    91   */   LonApiNoIpAddress            = 91,  /* No IP address defined.  See LonGetMyIpAddress in FtxlHandlers.c. */
    /*    92   */   LonUnknownLTSDeviceType      = 92,  /* Unknown LTS device type */ 
    /*    93   */   LonInvalidDeviceURI          = 93  /* Unknown LTS device URI */ 

} LON_ENUM_END(LonApiError);

/*
 * Macro: LON_SUCCESS
 * Use the LON_SUCCESS macro to convert a <LonApiError> code into a boolean 
 * success or failure indicator.
 */
#define LON_SUCCESS(n)   ((n) == LonApiNoError)

/*
 * ******************************************************************************
 * SECTION: GENERAL ENUMERATIONS AND TYPES
 * ******************************************************************************
 *
 * This section contains the enumerations and data types used with the IzoT Device 
 * Stack 1.0 API
 */

/*
 *  Macros: LON_GET_UNSIGNED_WORD, LON_SET_UNSIGNED_WORD
 *  Converts a LonWord into a LonUbits16 and converts a LonUbits16 into a 
 *  LonWord.
 */
#define LON_GET_UNSIGNED_WORD(n)          (((LonUbits16)((n).msb) << 8)+(LonUbits16)((n).lsb))
#define LON_SET_UNSIGNED_WORD(n, v)       (n).msb = (LonByte)((v)>>8); (n).lsb = (LonByte)(v)

/*
 *  Macros: LON_GET_SIGNED_WORD, LON_SET_SIGNED_WORD
 *  Converts a LonWord into a LonBits16 and converts a LonBits16 into a 
 *  LonWord.
 */
#define LON_GET_SIGNED_WORD(n)            ((LonBits16)LON_GET_UNSIGNED_WORD(n))
#define LON_SET_SIGNED_WORD(n, v)         LON_SET_UNSIGNED_WORD(n, v)

/*
 *  Macros: LON_GET_UNSIGNED_DOUBLEWORD, LON_SET_UNSIGNED_DOUBLEWORD
 *  Converts a LonDoubleWord into a LonUbits32 and converts a LonUbits32 into 
 *  a LonDoubleWord.
 */
#define LON_GET_UNSIGNED_DOUBLEWORD(n)    ((((LonUbits32)LON_GET_UNSIGNED_WORD((n).msw)) << 16) \
                                          +(LonUbits32)LON_GET_UNSIGNED_WORD((n).lsw))
#define LON_SET_UNSIGNED_DOUBLEWORD(n, v) LON_SET_UNSIGNED_WORD((n).msw, (LonBits16) ((v) >> 16)); \
                                          LON_SET_UNSIGNED_WORD((n).lsw, (LonBits16) (v))

/*
 *  Macros: LON_GET_SIGNED_DOUBLEWORD, LON_SET_SIGNED_DOUBLEWORD
 *  Converts a LonDoubleWord into a LonBits32 and converts a LonBits32 into a 
 *  LonDoubleWord.
 */
#define LON_GET_SIGNED_DOUBLEWORD(n)    ((LonBits32)LON_GET_UNSIGNED_DOUBLEWORD(n))
#define LON_SET_SIGNED_DOUBLEWORD(n, v) LON_SET_UNSIGNED_DOUBLEWORD(n, v)

/*
 *  Macros: LON_GET_ATTRIBUTE, LON_SET_ATTRIBUTE
 *  Gets(sets) attributes from(to) a field by appropriately masking and shifting.
 */
#define LON_GET_ATTRIBUTE(var, n)           ((((var).n##_FIELD) & n##_MASK) >> n##_SHIFT)
#define LON_GET_ATTRIBUTE_P(var, n)         ((((var)->n##_FIELD) & n##_MASK) >> n##_SHIFT)
#define LON_SET_ATTRIBUTE(var, n, value)    ((var).n##_FIELD = (((var).n##_FIELD) & ~n##_MASK) | (((value) << n##_SHIFT) & n##_MASK))
#define LON_SET_ATTRIBUTE_P(var, n, value)  ((var)->n##_FIELD = (((var)->n##_FIELD) & ~n##_MASK) | (((value) << n##_SHIFT) & n##_MASK))

/*
 *  Macro: LON_DOMAIN_ID_MAX_LENGTH 
 *  Maximum length of the domain identifier, in bytes.
 *
 *  The domain identifier can be zero, one, three, or 
 *  LON_DOMAIN_ID_MAX_LENGTH (6) bytes long.  Space for the largest possible 
 *  identifier is allocated in various structures and message types. See 
 *  <LonDomain> for the domain table structure.
 */
#define LON_DOMAIN_ID_MAX_LENGTH    6

/*
 *  Macro: LON_AUTHENTICATION_KEY_LENGTH  
 *  Length of the authentication key, stored in the domain table (<LonDomain>). 
 */
#define LON_AUTHENTICATION_KEY_LENGTH   6

/*
 *  Macro: LON_PROGRAM_ID_LENGTH
 *  Length of the application's program identifier, in bytes.
 */
#define LON_PROGRAM_ID_LENGTH   8

/*
 *  Macro: LON_LOCATION_LENGTH  
 *  Length of the location identifier, in bytes.
 */
#define LON_LOCATION_LENGTH     6

/*
 *  Macro: LON_UNIQUE_ID_LENGTH
 *  Length of the node's unique identifier, in bytes.
 *
 *  The Unique ID is also known as the Neuron ID, referring to the
 *  Neuron Chip's or Smart Transceiver's unique ID. 
 */
#define LON_UNIQUE_ID_LENGTH    6

/*
 *  Macro: LON_COMMUNICATIONS_PARAMETER_LENGTH
 *  Number of communication control bytes.
 */
#define LON_COMMUNICATIONS_PARAMETER_LENGTH     7

/*
 *  Typedef: LonTransceiverParameters
 *  Parameters for single-ended and special-purpose mode transceivers.
 *
 *  See <LonDirectModeTransceiver> for direct-mode transceiver parameters.
 */
typedef LonByte  LonTransceiverParameters[LON_COMMUNICATIONS_PARAMETER_LENGTH];

/*
 *  Typedef: LonUniqueId
 *  Holds the unique ID.
 */
typedef LonByte  LonUniqueId[LON_UNIQUE_ID_LENGTH];

/*
 *  Typedef: LonProgramId
 *  Holds the program ID.
 */
typedef LonByte  LonProgramId[LON_PROGRAM_ID_LENGTH];

/*
 *  Typedef: LonDomainId
 *  Holds a single domain identifier.
 */
typedef LonByte  LonDomainId[LON_DOMAIN_ID_MAX_LENGTH];

/*
 *  Typedef: LonAuthenticationKey
 *  Holds a single authentication key.
 */
typedef LonByte  LonAuthenticationKey[LON_AUTHENTICATION_KEY_LENGTH];

/*
 *  Typedef: LonLocationId
 *  Holds a single location identifier.
 *
 *  The location identifier is often referred to as the "location string". 
 *  Note that this is misleading, because this data is not limited to ASCII 
 *  characters or other similar requirements that could be inferred from the 
 *  word "string".
 */
typedef LonByte  LonLocationId[LON_LOCATION_LENGTH];

/*
 *  Typedef: LonSubnetId
 *  Holds a subnet identifier.
 */
typedef LonByte  LonSubnetId;

/*
 *  Typedef: LonGroupId
 *  Holds a group identifier.
 */
typedef LonByte  LonGroupId;

/*
 *  Typedef: LonNodeId
 *  Holds a node identifier. 
 */
typedef LonByte  LonNodeId;

/* 
 *  Enumeration: LonNeuronModel
 *  Neuron Chip and Smart Transceiver model codes.
 *
 *  This enumeration lists all model codes for Neuron Chips or Smart 
 *  Transceivers.
 */
typedef LON_ENUM_BEGIN(LonNeuronModel) 
{
    /*  0 */    LonNeuron3150Code    =  0,  /* 3150, FT 3150 */
    /*  1 */    LonNeuronPl3150Code  =  1,  /* PL 3150 */ 
    /*  2 */    LonNeuron3150LCode   =  2,  /* CY7C53150L */
    /*  8 */    LonNeuron3120Code    =  8,  /* Legacy 3120 */
    /*  9 */    LonNeuron3120E1Code  =  9,  /* 3120E1, TMPN3120FE1M */
    /* 10 */    LonNeuron3120E2Code  = 10,  /* 3120E2 */
    /* 11 */    LonNeuron3120E3Code  = 11,  /* 3120E3, TMPN3120FE3M */
    /* 12 */    LonNeuron3120A20Code = 12,  /* 3120A20 */
    /* 13 */    LonNeuron3120E5Code  = 13,  /* 3120E5, TMPN3120FE5M */
    /* 14 */    LonNeuron3120E4Code  = 14,  /* CY7C53120E4, FT 3120-E4 */
    /* 15 */    LonNeuronPl3120E4Code= 15,  /* PL 3120-E4 */
    /* 16 */    LonNeuron3120L8Code  = 16,  /* CY7C53120L8 */
    /* 17 */    LonNeuronPl3170Code  = 17   /* PL 3170 */
} LON_ENUM_END(LonNeuronModel);

/*
 *  Enumeration: LonNeuronState
 *  Neuron Chip and Smart Transceiver state values.
 *
 *  This enumeration contains the values of the Neuron Chip's or Smart 
 *  Transceiver's state information.  To convert the state value returned by 
 *  the Query Status command to one of these values, use the <LON_NODE_STATE> 
 *  macro. To test for the offline flag, use the <LON_NODE_STATE_OFFLINE> macro.
 */

#define LON_OFFLINE_BIT 0x08
#define LON_NODE_STATE_MASK 0x07

/*
 *  Macro: LON_NEURON_STATE
 *  Obtain persistent Neuron state information.
 *
 *  Use this macro to obtain the 3-bit Neuron state that is stored in EEPROM.
 */
#define LON_NEURON_STATE(state) ((state) & LON_NODE_STATE_MASK)

/*
 *  Macro: LON_NODE_STATE
 *  Extracts state information from <LonNeuronState>.
 *
 *  Use this macro to decipher the status information encoded within the 
 *  <LonNeuronState> enumeration.
 */
#define LON_NODE_STATE(state)   ((LON_NEURON_STATE(state) == LonConfigOnLine) ? (state) : LON_NEURON_STATE(state))

/*
 *  Macro: LON_NODE_STATE_OFFLINE
 *  Extracts offline details from <LonNeuronState>.
 *
 *  Use this macro to query the node's offline modes. 
 */
#define LON_NODE_STATE_OFFLINE(state)   (LON_NEURON_STATE(state) == LonConfigOffLine || LON_NEURON_STATE(state) == LonSoftOffLine)

/*
 *  Typedef: LonNodeState
 *  Decodes the node's state.
 */
typedef LON_ENUM_BEGIN(LonNodeState) 
{
    /*  0 */    LonStateInvalid          = 0,    /* invalid or Echelon use only          */
    /*  1 */    LonStateInvalid_1        = 1,    /* equivalent to StateInvalid          */
    /*  2 */    LonApplicationUnconfig   = 2,    /* has application, unconfigured        */
    /*  3 */    LonNoApplicationUnconfig = 3,    /* applicationless, unconfigured        */
    /*  4 */    LonConfigOnLine          = 4,    /* configured, online                   */
    /*  5 */    LonStateInvalid_5        = 5,    /* equivalent to StateInvalid          */
    /*  6 */    LonConfigOffLine         = 6,    /* hard offline                         */
    /*  7 */    LonStateInvalid_7        = 7,    /* equivalent to StateInvalid          */
    /* 12 */    LonSoftOffLine           = (LonConfigOnLine|LON_OFFLINE_BIT), /* (12) configured, soft-offline        */
    /*0x8C*/    LonConfigByPass          = 0x8C  /* configured, in bypass mode    */
} LON_ENUM_END(LonNodeState);

/*
 * Enumeration: LonNodeMode
 * Control node mode with <LonNmSetNodeModeRequest>.
*/
typedef LON_ENUM_BEGIN(LonNodeMode) 
{
    LonApplicationOffLine  = 0,
    LonApplicationOnLine   = 1,
    LonApplicationReset    = 2,
    LonChangeState         = 3
} LON_ENUM_END(LonNodeMode);

/*
 *  Enumeration: LonResetCause
 *  Decodes the last reset cause.
*/
typedef LON_ENUM_BEGIN(LonResetCause) 
{
    /* 0x00 */  LonResetCleared = 0x00,
    /* 0x01 */  LonPowerUpReset = 0x01,
    /* 0x02 */  LonExternalReset = 0x02,
    /* 0x0C */  LonWatchdogReset = 0x0C,
    /* 0x14 */  LonSoftwareReset = 0x14
} LON_ENUM_END(LonResetCause);

/*
 *  Enumeration: LonAddressType
 *  Denotes destination address type.
 *
 *  This enumeration holds the literals for the 'type' field of destination 
 *  addresses for outgoing messages.
 */
typedef LON_ENUM_BEGIN(LonAddressType) 
{
    /*  0 */    LonAddressUnassigned    = 0,
    /*  1 */    LonAddressSubnetNode,
    /*  2 */    LonAddressUniqueId,  
    /*  3 */    LonAddressBroadcast,
    /*127 */    LonAddressLocal = 127
} LON_ENUM_END(LonAddressType);

/*
 *  Enumeration: LonRepeatTimer
 *  Encoded repeat timer values.
 *
 *  This enumeration defines the encoded repeat timer values.
 */
typedef LON_ENUM_BEGIN(LonRepeatTimer) 
{
    /*  0 */ LonRpt16,      /* 16 ms */
    /*  1 */ LonRpt24,      /* 24 ms */
    /*  2 */ LonRpt32,      /* 32 ms */
    /*  3 */ LonRpt48,      /* 48 ms */
    /*  4 */ LonRpt64,      /* 64 ms */
    /*  5 */ LonRpt96,      /* 96 ms */
    /*  6 */ LonRpt128,     /* 128 ms */
    /*  7 */ LonRpt192,     /* 192 ms */
    /*  8 */ LonRpt256,     /* 256 ms */
    /*  9 */ LonRpt384,     /* 384 ms */
    /* 10 */ LonRpt512,     /* 512 ms */
    /* 11 */ LonRpt768,     /* 768 ms */
    /* 12 */ LonRpt1024,    /* 1024 ms */
    /* 13 */ LonRpt1536,    /* 1536 ms */
    /* 14 */ LonRpt2048,    /* 2048 ms */
    /* 15 */ LonRpt3072     /* 3072 ms */
} LON_ENUM_END(LonRepeatTimer);

/*
 *  Enumeration: LonReceiveTimer
 *  Encoded receive timer values.
 *
 *  This enumeration defines the encoded receive timer values used with groups. 
 *  For the non-group receive timer, see <LonNonGroupReceiveTimer>.
 */
typedef LON_ENUM_BEGIN(LonReceiveTimer) 
{
    /*  0 */ LonRcv128,     /* 128 ms */
    /*  1 */ LonRcv192,     /* 192 ms */
    /*  2 */ LonRcv256,     /* 256 ms */
    /*  3 */ LonRcv384,     /* 384 ms */
    /*  4 */ LonRcv512,     /* 512 ms */
    /*  5 */ LonRcv768,     /* 768 ms */
    /*  6 */ LonRcv1024,    /* 1024 ms */
    /*  7 */ LonRcv1536,    /* 1536 ms */
    /*  8 */ LonRcv2048,    /* 2048 ms */
    /*  9 */ LonRcv3072,    /* 3072 ms */
    /* 10 */ LonRcv4096,    /* 4096 ms */
    /* 11 */ LonRcv6144,    /* 6144 ms */
    /* 12 */ LonRcv8192,    /* 8192 ms */
    /* 13 */ LonRcv12288,   /* 12288 ms */
    /* 14 */ LonRcv16384,   /* 16384 ms */
    /* 15 */ LonRcv24576    /* 24576 ms */
} LON_ENUM_END(LonReceiveTimer);

/*
 *  Enumeration: LonNonGroupReceiveTimer
 *  Encoded non-group receive timer values.
 *
 *  This enumeration defines the encoded values for the receive timer used 
 *  with any addressing modes other than groups. For the receive timer used 
 *  with groups, use <LonReceiveTimer>. 
 */
typedef LonReceiveTimer LonNonGroupReceiveTimer;

/*
 *  Enumeration: LonTransmitTimer
 *  Encoded transmit timer values.
 *
 *  This enumeration defines the encoded transmit timer values.
 */
typedef LON_ENUM_BEGIN(LonTransmitTimer) 
{
    /*  0 */ LonTx16,      /* 16 ms */
    /*  1 */ LonTx24,      /* 24 ms */
    /*  2 */ LonTx32,      /* 32 ms */
    /*  3 */ LonTx48,      /* 48 ms */
    /*  4 */ LonTx64,      /* 64 ms */
    /*  5 */ LonTx96,      /* 96 ms */
    /*  6 */ LonTx128,     /* 128 ms */
    /*  7 */ LonTx192,     /* 192 ms */
    /*  8 */ LonTx256,     /* 256 ms */
    /*  9 */ LonTx384,     /* 384 ms */
    /* 10 */ LonTx512,     /* 512 ms */
    /* 11 */ LonTx768,     /* 768 ms */
    /* 12 */ LonTx1024,    /* 1024 ms */
    /* 13 */ LonTx1536,    /* 1536 ms */
    /* 14 */ LonTx2048,    /* 2048 ms */
    /* 15 */ LonTx3072     /* 3072 ms */
} LON_ENUM_END(LonTransmitTimer);


/*
 * Enumeration: LontalkStackUriScheme
 * Schemes supported in LontalkStack device URI 
 */
typedef LON_ENUM_BEGIN(LontalkStackUriScheme) 
{
    IPUnicast           = 0,
    IPMulticast         = 1,
    Ldv                 = 2,
    IPNative            = 3,
    IPNativeEnhanced    = 4,
    SchemeCount,
} LON_ENUM_END(LontalkStackUriScheme);


/*
 * Enumeration: LtServicePinState
 * The service pin state
*/
#ifndef _LTDRIVER_H
#undef LtServicePinState
typedef LON_ENUM_BEGIN(LtServicePinState)
{
    SERVICE_OFF = 0,
    SERVICE_ON = 1,
    SERVICE_BLINKING = 2,

    // Software controlled only
    SERVICE_FLICKER = -1
} LON_ENUM_END(LtServicePinState);
#endif

/*
 * ******************************************************************************
 * SECTION: ADDRESSING TYPES
 * ******************************************************************************
 *
 *  This section contains definitions used with source addresses, destination 
 *  addresses, and the address table. 
 */

/*
 *  Typedef: LonSendGroup
 *  Destination address type for group addressing.  
 *
 *  Group address structure, used for multicast destination addresses with 
 * <LonSendAddress>.
 */

/*
 * Use the LON_SENDGROUP_TYPE_* macros to access the Type field in LonSendGroup.TypeSize
 */
#define LON_SENDGROUP_TYPE_MASK     0x80    /* One for group, zero for all other address types */
#define LON_SENDGROUP_TYPE_SHIFT    7
#define LON_SENDGROUP_TYPE_FIELD    TypeSize

/*
 * Use the LON_SENDGROUP_SIZE_* macros to access the Size field in 
 * LonSendGroup.TypeSize
 */
#define LON_SENDGROUP_SIZE_MASK     0x7F    /* group size, or zero for unlimited group size */
#define LON_SENDGROUP_SIZE_SHIFT    0
#define LON_SENDGROUP_SIZE_FIELD    TypeSize

/*
 * Use the LON_SENDGROUP_DOMAIN_* macros to access the Domain field in 
 * LonSendGroup.DomainMember
 */
#define LON_SENDGROUP_DOMAIN_MASK   0x80    /* domain index for this group, zero or one */
#define LON_SENDGROUP_DOMAIN_SHIFT  7
#define LON_SENDGROUP_DOMAIN_FIELD  DomainMember

/*
 * Use the LON_SENDGROUP_MEMBER_* macros to access the Member field in 
 * LonSendGroup.DomainMember
 */
#define LON_SENDGROUP_MEMBER_MASK   0x7F    /* member ID within the group (0-63). Use zero for unlimited groups. */
#define LON_SENDGROUP_MEMBER_SHIFT  0
#define LON_SENDGROUP_MEMBER_FIELD  DomainMember

/*
 * Use the LON_SENDGROUP_REPEAT_TIMER_* macros to access the Repeat field in 
 * LonSendGroup.RepeatRetry 
 */
#define LON_SENDGROUP_REPEAT_TIMER_MASK 0xF0    /* repeat timer. Use values from the <LonRepeatTimer> enumeration. */
#define LON_SENDGROUP_REPEAT_TIMER_SHIFT  4
#define LON_SENDGROUP_REPEAT_TIMER_FIELD  RepeatRetry

/*
 * Use the LON_SENDGROUP_RETRY_* macros to access the Retry field in 
 * LonSendGroup.RepeatRetry
 */
#define LON_SENDGROUP_RETRY_MASK    0x0F    /* number of retries, or number of transmissions minus one for unacknowledged service */
#define LON_SENDGROUP_RETRY_SHIFT   0
#define LON_SENDGROUP_RETRY_FIELD   RepeatRetry

/*
 * Use the LON_SENDGROUP_RECEIVE_TIMER_* macros to access the Receive Timer 
 * field in LonSendGroup.ReceiveTransmit
 */
#define LON_SENDGROUP_RECEIVE_TIMER_MASK 0xF0   /* receive timer. Use values from the <LonReceiveTimer> enumeration. */
#define LON_SENDGROUP_RECEIVE_TIMER_SHIFT 4
#define LON_SENDGROUP_RECEIVE_TIMER_FIELD ReceiveTransmit

/*
 * Use the LON_SENDGROUP_TRANSMIT_TIMER_* macros to access the TransmitTimer 
 * field in LonSendGroup.ReceiveTransmit
 */
#define LON_SENDGROUP_TRANSMIT_TIMER_MASK 0x0F   /* receive timer. Use values from the <LonTransmitTimer> enumeration. */
#define LON_SENDGROUP_TRANSMIT_TIMER_SHIFT 0
#define LON_SENDGROUP_TRANSMIT_TIMER_FIELD ReceiveTransmit

typedef LON_STRUCT_BEGIN(LonSendGroup) 
{
    LonByte  TypeSize;       /* contains type, size. See LON_SENDGROUP_TYPE_* and _SIZE_* macros. */
    LonByte  DomainMember;   /* contains domain, member. See LON_SENDGROUP_DOMAIN_* and _MEMBER_* macros. */
    LonByte  RepeatRetry;    /* contains repeat, retry. See LON_SENDGROUP_REPEAT_* and _RETRY_* macros. */
    LonByte  ReceiveTransmit;/* contains receive and transmit timers. See LON_SENDGROUP_RECEIVE_* and _TRANSMIT_* macros. */
    LonGroupId GroupId;      /* the group ID, 0..255 */
} LON_STRUCT_END(LonSendGroup);

/*
 *  Typedef: LonSendSubnetNode
 *  Destination address type for subnet/node addressing.  
 *
 *  Subnet/Node address structure, used for unicast destination addresses with 
 *  <LonSendAddress>.
 */

/*
 * Use the LON_SENDSN_DOMAIN_* macros to access the Domain field in 
 * LonSendSubnetNode.DomainNode
 */
#define LON_SENDSN_DOMAIN_MASK  0x80    /* domain index, zero or one */
#define LON_SENDSN_DOMAIN_SHIFT 7
#define LON_SENDSN_DOMAIN_FIELD DomainNode

/*
 * Use the LON_SENDSN_NODE_* and LON_NODEID_* macros to access the Node field 
 * in LonSendSubnetNode.DomainNode
 */
#define LON_SENDSN_NODE_MASK     0x7F    /* node ID 0-127 in this subnet, this domain */
#define LON_SENDSN_NODE_SHIFT    0
#define LON_SENDSN_NODE_FIELD    DomainNode

/*
 * Use the LON_SENDSN_REPEAT_* macros to access the Repeat field in 
 * LonSendSubnetNode.RepeatRetry
 */
#define LON_SENDSN_REPEAT_TIMER_MASK     0xF0    /* repeat timer. Use values from the <LonRepeatTimer> enumeration. */
#define LON_SENDSN_REPEAT_TIMER_SHIFT    4
#define LON_SENDSN_REPEAT_TIMER_FIELD    RepeatRetry

/*
 * Use the LON_SENDSN_RETRY_* macros to access the Retry field in 
 * LonSendSubnetNode.RepeatRetry
 */
#define LON_SENDSN_RETRY_MASK   0x0F    /* repeat timer. Use values from the <LonRepeatTimer> enumeration. */
#define LON_SENDSN_RETRY_SHIFT  0
#define LON_SENDSN_RETRY_FIELD  RepeatRetry

/*
 * Use the LON_SENDSN_RSVD0_* macros to access the rsvd0 field in 
 * LonSendSubnetNode.RsvdTransmit
 */
#define LON_SENDSN_RSVD0_MASK     0xF0    /* repeat timer. Use values from the <LonRepeatTimer> enumeration. */
#define LON_SENDSN_RSVD0_SHIFT    4
#define LON_SENDSN_RSVD0_FIELD    RsvdTransmit

/*
 * Use the LON_SENDSN_TRANSMIT_TIMER_* macros to access the transmit timer 
 * field in LonSendSubnetNode.RsvdTransmit
 */
#define LON_SENDSN_TRANSMIT_TIMER_MASK   0x0F    /* repeat timer. Use values from the <LonRepeatTimer> enumeration. */
#define LON_SENDSN_TRANSMIT_TIMER_SHIFT  0
#define LON_SENDSN_TRANSMIT_TIMER_FIELD  RsvdTransmit

typedef LON_STRUCT_BEGIN(LonSendSubnetNode) 
{
    LON_ENUM(LonAddressType) Type;   /* should be LonAddressSubnetNode for subnet/node addressing */
    LonByte  DomainNode;             /* contains domain, node. See LON_SENDSN_DOMAIN_* and _NODE_* macros. */
    LonByte  RepeatRetry;            /* contains repeat, retry. See LON_SENDSN_REPEAT_* and _RETRY_* macros. */
    LonByte  RsvdTransmit;           /* contains rsvd0, transmit. See LON_SENDSN_RSVD0_* and _TRANSMIT_TIMER_* macros. */
    LonSubnetId Subnet;              /* destination subnet number, 1..255    */
} LON_STRUCT_END(LonSendSubnetNode);

/*
 *  Typedef: LonSendUniqueId
 *  Destination address type for Unique ID (Neuron ID) addressing.  
 *
 *  Unique ID (Neuron ID) address structure, used for unicast destination 
 *  addresses with <LonSendAddress>.
 */

/*
 * Use the LON_SENDNID_DOMAIN_* macros to access the Domain field in 
 * LonSendUniqueId.DomainNode
 */
#define LON_SENDNID_DOMAIN_MASK     0x80    /* domain index, zero or one */
#define LON_SENDNID_DOMAIN_SHIFT    7
#define LON_SENDNID_DOMAIN_FIELD    Domain

/*
 * Use the LON_SENDNID_REPEAT_* macros to access the Repeat field in 
 * LonSendUniqueId.RepeatRetry
 */
#define LON_SENDNID_REPEAT_TIMER_MASK     0xF0    /* repeat timer. Use values from the <LonRepeatTimer> enumeration. */
#define LON_SENDNID_REPEAT_TIMER_SHIFT    4
#define LON_SENDNID_REPEAT_TIMER_FIELD    RepeatRetry

/*
 * Use the LON_SENDNID_RETRY_* macros to access the Retry field in 
 * LonSendUniqueId.RepeatRetry
 */
#define LON_SENDNID_RETRY_MASK         0x0F    /* repeat timer. Use values from the <LonRepeatTimer> enumeration. */
#define LON_SENDNID_RETRY_SHIFT        0
#define LON_SENDNID_RETRY_FIELD        RepeatRetry

/*
 * Use the LON_SENDNID_RSVD0_* macros to access the rsvd0 field in 
 * LonSendUniqueId.RsvdTransmit
 */
#define LON_SENDNID_RSVD0_MASK     0xF0    /* repeat timer. Use values from the <LonRepeatTimer> enumeration. */
#define LON_SENDNID_RSVD0_SHIFT    4
#define LON_SENDNID_RSVD0_FIELD    RsvdTransmit

/*
 * Use the LON_SENDNID_TRANSMIT_TIMER_* macros to access the transmit timer 
 * field in LonSendUniqueId.RsvdTransmit
 */
#define LON_SENDNID_TRANSMIT_TIMER_MASK   0x0F    /* repeat timer. Use values from the <LonRepeatTimer> enumeration. */
#define LON_SENDNID_TRANSMIT_TIMER_SHIFT  0
#define LON_SENDNID_TRANSMIT_TIMER_FIELD  RsvdTransmit

typedef LON_STRUCT_BEGIN(LonSendUniqueId) 
{
    LON_ENUM(LonAddressType) Type;   /* should be LonAddressUniqueId */
    LonByte  Domain;                 /* contains the domain index. See LON_SENDNID_DOMAIN_* macro. The remaining 7 bits must be zero. */
    LonByte  RepeatRetry;            /* contains repeat, retry. See LON_SENDNID_REPEAT_* and _RETRY_* macros. */
    LonByte  RsvdTransmit;
    LonSubnetId Subnet;              /* destination subnet number, 1..255, or zero to pass all routers */
    LonUniqueId NeuronId;            /* 48-bit unique ID of Neuron Chip or Smart Transceiver */
} LON_STRUCT_END(LonSendUniqueId);

/*
 *  Typedef: LonSendBroadcast
 *  Destination address type for broadcast addressing.  
 *
 *  Broadcast address structure, used for multicast destination addresses with 
 *  <LonSendAddress>.
 */

/*
 * Use the LON_SENDBCAST_DOMAIN_* macros to access the Domain filed in 
 * LonSendBroadcast.DomainRsvdBacklog
 */
#define LON_SENDBCAST_DOMAIN_MASK     0x80    /* domain index, zero or one */
#define LON_SENDBCAST_DOMAIN_SHIFT    7
#define LON_SENDBCAST_DOMAIN_FIELD    DomainRsvdBacklog

/*
 * Use the LON_SENDBCAST_RSVD0_* macros to access the rsvd0 field in 
 * LonSendBroadcast.DomainRsvdBacklog
 */
#define LON_SENDBCAST_RSVD0_MASK     0x40    /* repeat timer. Use values from the <LonRepeatTimer> enumeration. */
#define LON_SENDBCAST_RSVD0_SHIFT    6
#define LON_SENDBCAST_RSVD0_FIELD    DomainRsvdBacklog

/*
 * Use the LON_SENDBCAST_BACKLOG_* macros to access the Backlog field in 
 * LonSendBroadcast.DomainRsvdBacklog
 */
#define LON_SENDBCAST_BACKLOG_MASK  0x3F   /* backlog (set to zero if unknown) */
#define LON_SENDBCAST_BACKLOG_SHIFT 0
#define LON_SENDBCAST_BACKLOG_FIELD DomainRsvdBacklog

/*
 * Use the LON_SENDBCAST_REPEAT_* macros to access the Repeat field in 
 * LonSendBroadcast.RepeatRetry
 */
#define LON_SENDBCAST_REPEAT_TIMER_MASK     0xF0    /* repeat timer. Use values from the <LonRepeatTimer> enumeration. */
#define LON_SENDBCAST_REPEAT_TIMER_SHIFT    4
#define LON_SENDBCAST_REPEAT_TIMER_FIELD    RepeatRetry

/*
 * Use the LON_SENDBCAST_RETRY_* macros to access the Retry field in 
 * LonSendBroadcast.RepeatRetry
 */
#define LON_SENDBCAST_RETRY_MASK     0x0F    /* repeat timer. Use values from the <LonRepeatTimer> enumeration. */
#define LON_SENDBCAST_RETRY_SHIFT    0
#define LON_SENDBCAST_RETRY_FIELD    RepeatRetry

/*
 * Use the LON_SENDNID_RSVD1_* macros to access the rsvd1 field in 
 * LonSendBroadcast.RsvdTransmit
 */
#define LON_SENDBCAST_RSVD1_MASK     0xF0    /* repeat timer. Use values from the <LonRepeatTimer> enumeration. */
#define LON_SENDBCAST_RSVD1_SHIFT    4
#define LON_SENDBCAST_RSVD1_FIELD    RsvdTransmit

/*
 * Use the LON_SENDBCAST_TRANSMIT_TIMER_* macros to access the transmit timer 
 * field in LonSendBroadcast.RsvdTransmit
 */
#define LON_SENDBCAST_TRANSMIT_TIMER_MASK   0x0F    /* repeat timer. Use values from the <LonRepeatTimer> enumeration. */
#define LON_SENDBCAST_TRANSMIT_TIMER_SHIFT  0
#define LON_SENDBCAST_TRANSMIT_TIMER_FIELD  RsvdTransmit

typedef LON_STRUCT_BEGIN(LonSendBroadcast) 
{
    LON_ENUM(LonAddressType) Type;   /* should be LonAddressBroadcast */
    LonByte  DomainRsvdBacklog;      /* contains domain, rsvd0, backlog. See LON_SENDBCAST_DOMAIN_*, _RSVD0_* and _BACKLOG_* macros. */
    LonByte  RepeatRetry;            /* contains repeat, retry. See LON_SENDBCAST_REPEAT_* and _RETRY_* macros. */
    LonByte  RsvdTransmit;
    LonSubnetId Subnet;             /* destination subnet number, 1..255 for subnet broadcast, zero for domain broadcast */
} LON_STRUCT_END(LonSendBroadcast);

/*
 *  Typedef: LonSendUnassigned
 *  Address format to clear an address table entry.
 *
 *  Sets the first 2 bytes of the address table entry to 0.
 */
typedef LON_STRUCT_BEGIN(LonSendUnassigned) 
{
    LON_ENUM(LonAddressType) Type;   /* should be LonAddressUnassigned */
} LON_STRUCT_END(LonSendUnassigned);

/*
 *  Typedef: LonSendLocal
 *  Destination address type to address the node locally with <LonSendAddress>.  
 *
 */
typedef LON_STRUCT_BEGIN(LonSendLocal) 
{
    LON_ENUM(LonAddressType) Type;   /* should be LonAddressLocal */
} LON_STRUCT_END(LonSendLocal);

/*
 * Typedef: LonSendAddress
 * Union of all possible destination address formats. 
 */
typedef LON_UNION_BEGIN(LonSendAddress) 
{
    LonSendUnassigned   Unassigned;
    LonSendGroup        Group;      
    LonSendSubnetNode   SubnetNode;
    LonSendBroadcast    Broadcast;
    LonSendUniqueId     UniqueId;
    LonSendLocal        Local;
} LON_UNION_END(LonSendAddress);

/*
 *  Typedef: LonReceiveSubnetNode
 *  Received subnet/node ID destination addresses, used with unicast messages.
 *
 *  Used with <LonReceiveDestination> and <LonReceiveAddress>.
 */

/*
 * Use the LON_RECEIVESN_NODE_* macros to access the LonReceiveSubnetNode.Node 
 * field
 */
#define LON_RECEIVESN_NODE_MASK  0x7F    /* node Id 0..127, MSB is reserved */
#define LON_RECEIVESN_NODE_SHIFT 0
#define LON_RECEIVESN_NODE_FIELD Node

typedef LON_STRUCT_BEGIN(LonReceiveSubnetNode) 
{
    LonByte  Subnet;
    LonByte  Node;       /* node identifier, use LON_RECEIVESN_NODE_* macros */
} LON_STRUCT_END(LonReceiveSubnetNode);

/*
 *  Typedef: LonReceiveUniqueId
 *  Received 48-bit unique ID (Neuron ID) destination address. 
 *
 *  Used with <LonReceiveDestination>.
 */
typedef LON_STRUCT_BEGIN(LonReceiveUniqueId) 
{
    LonSubnetId Subnet;
    LonUniqueId UniqueId;
} LON_STRUCT_END(LonReceiveUniqueId);

/*
 *  Typedef: LonReceiveGroup
 *  Received a group destination address.
 *
 *  Used with <LonReceiveDestination>.
 */
typedef LON_STRUCT_BEGIN(LonReceiveGroup) 
{
    LonGroupId GroupId;             /* 0..255 */
} LON_STRUCT_END(LonReceiveGroup);

/*
 *  Typedef: LonReceiveBroadcast
 *  Received a broadcast destination address.
 *
 *  Used with <LonReceiveDestination>.
 */
typedef LON_STRUCT_BEGIN(LonReceiveBroadcast) 
{
    LonSubnetId SubnetId;       /* 1..255 for subnet broadcast, zero for domain broadcast */
} LON_STRUCT_END(LonReceiveBroadcast);

/*
 *  Typedef: LonReceiveDestination
 *  Union of all possible address formats for receiving an incoming message.
 */
typedef LON_UNION_BEGIN(LonReceiveDestination) 
{
    LonReceiveBroadcast     Broadcast;
    LonReceiveGroup         Group;
    LonReceiveSubnetNode    SubnetNode;
    LonReceiveUniqueId      UniqueId;
} LON_UNION_END(LonReceiveDestination);

/*
 *  Enumeration: LonReceiveDestinationAddressFormat
 *  Encodes the format of the receive address.
 *
 *  This enumeration encodes the format of the receive address of an incoming 
 *  message, allowing you to select the corresponding member in 
 *  <LonReceiveDestination>.
 */
typedef LON_ENUM_BEGIN(LonReceiveDestinationAddressFormat) 
{
    /*  0 */ LonReceiveDestinationAddressBroadcast  = 0,
    /*  1 */ LonReceiveDestinationAddressGroup,
    /*  2 */ LonReceiveDestinationAddressSubnetNode,
    /*  3 */ LonReceiveDestinationAddressUniqueId,
    /*  4 */ LonReceiveDestinationAddressTurnaround
} LON_ENUM_END(LonReceiveDestinationAddressFormat);

/*
 *  Typedef: LonReceiveAddress
 *  Receive destination and source address for incoming messages.
 *
 *  This structure holds the receive destination address of an incoming message 
 *  (the address through which the message was received on this node) and the 
 *  message's source address (where it came from). 
 */
#define LON_RECEIVEADDRESS_DOMAIN_MASK   0x80    /* domain table index through which the message was received */
#define LON_RECEIVEADDRESS_DOMAIN_SHIFT  7
#define LON_RECEIVEADDRESS_DOMAIN_FIELD  DomainFormat

#define LON_RECEIVEADDRESS_FLEX_MASK     0x40    /* one for flex domain, that is, received message on unconfigured node */
#define LON_RECEIVEADDRESS_FLEX_SHIFT    6
#define LON_RECEIVEADDRESS_FLEX_FIELD    DomainFormat

#define LON_RECEIVEADDRESS_FORMAT_MASK   0x3F    /* use <LonReceiveDestinationAddressFormat> enumeration */
#define LON_RECEIVEADDRESS_FORMAT_SHIFT  0
#define LON_RECEIVEADDRESS_FORMAT_FIELD  DomainFormat

typedef LON_STRUCT_BEGIN(LonReceiveAddress) 
{
    LonByte  DomainFormat;   /* contains domain, flex domain, format. Use LON_RECEIVEADDRESS_* macros to access data. */
    LonReceiveSubnetNode    Source;
    LonReceiveDestination   Destination;
} LON_STRUCT_END(LonReceiveAddress);

/*
 *  Typedef: LonResponseSource
 *  Source address of a response message.
 *
 *  LonResponseSource holds the source address of a response message. 
 */
#define LON_RESPONSESOURCE_IS_SUBNETNODE_MASK   0x80    /* 1: subnet/node response. 0: group response. */
#define LON_RESPONSESOURCE_IS_SUBNETNODE_SHIFT  7
#define LON_RESPONSESOURCE_IS_SUBNETNODE_FIELD  Node

#define LON_RESPONSESOURCE_NODE_MASK     0x7F    /* Node ID of response source */
#define LON_RESPONSESOURCE_NODE_SHIFT    0
#define LON_RESPONSESOURCE_NODE_FIELD    Node

typedef LON_STRUCT_BEGIN(LonResponseSource) 
{
    LonByte  Subnet;     /* subnet ID */
    LonByte  Node;       /* contains node, isSubnetNode. Use LON_RESPONSESOURCE_NODE_* and LON_RESPONSESOURCE_IS_SUBNETNODE_* macros. */
} LON_STRUCT_END(LonResponseSource);

/*
 *  Typedef: LonResponseSubnetNode
 *  Destination of response to unicast request.
 *
 *  Used with <LonResponseDestination>.
 */

/*
 * Use the LON_RESPONSESN_NODE_* macros to access the 
 * LonReceiveSubnetNode.Node field
 */
#define LON_RESPONSESN_NODE_MASK  0x7F    /* node Id 0..127, MSB is reserved */
#define LON_RESPONSESN_NODE_SHIFT 0
#define LON_RESPONSESN_NODE_FIELD Node

typedef LON_STRUCT_BEGIN(LonResponseSubnetNode) 
{
    LonSubnetId Subnet;         /* subnet ID */
    LonByte     Node;           /* node ID, use LON_RESPONSESN_NODE_* macros */
} LON_STRUCT_END(LonResponseSubnetNode);

/*
 *  Typedef: LonResponseGroup
 *  Destination of response to multicast request.
 *
 *  Used with <LonResponseDestination>.
 */

/*
 * Use the LON_RESPONSESN_NODE_* macros to access the 
 * LonReceiveSubnetNode.Node field
 */
#define LON_RESPGROUP_NODE_MASK  0x7F    /* node Id 0..127, MSB is reserved */
#define LON_RESPGROUP_NODE_SHIFT 0
#define LON_RESPGROUP_NODE_FIELD Node

#define LON_RESPGROUP_MEMBER_MASK   0x3F
#define LON_RESPGROUP_MEMBER_SHIFT  0
#define LON_RESPGROUP_MEMBER_FIELD  Member

typedef LON_STRUCT_BEGIN(LonResponseGroup) 
{
    LonSubnetId Subnet;         /* subnet ID */
    LonByte     Node;
    LonByte     Group;
    LonByte        Member;         /* use LON_RESPGROUP_MEMBER_* macros for access */
} LON_STRUCT_END(LonResponseGroup);

/*
 *  Typedef: LonResponseDestination
 *  Destination of a response.
 */
typedef LON_UNION_BEGIN(LonResponseDestination) 
{
    LonResponseSubnetNode   SubnetNode;
    LonResponseGroup        Group;
} LON_UNION_END(LonResponseDestination);

/*
 *  Typedef: LonResponseAddress
 *  Address of incoming response.
 */
#define LON_RESPONSEADDRESS_DOMAIN_MASK     0x80    /* domain index, zero or one */
#define LON_RESPONSEADDRESS_DOMAIN_SHIFT    7
#define LON_RESPONSEADDRESS_DOMAIN_FIELD    Domain

#define LON_RESPONSEADDRESS_FLEX_MASK       0x40    /* 1: response from foreign domain */
#define LON_RESPONSEADDRESS_FLEX_SHIFT      6
#define LON_RESPONSEADDRESS_FLEX_FIELD      Domain

typedef LON_STRUCT_BEGIN(LonResponseAddress) 
{
    LonByte                 Domain;         /* contains domain, flex domain. Use LON_RESPONSEADDRESS_* macros. */
    LonResponseSource       Source;
    LonResponseDestination  Destination;
} LON_STRUCT_END(LonResponseAddress);

/*
 * Typedef: LonExplicitAddress
 * Holds explicit addressing details, if enabled.
 *
 * LonExplicitAddress holds the address details. 
 */
typedef LON_UNION_BEGIN(LonExplicitAddress) 
{
    LonReceiveAddress   Receive;
    LonSendAddress      Send;
    LonResponseAddress  Response;
} LON_UNION_END(LonExplicitAddress);

/*
 * Typedef: LonAddressTableGroup
 * Holds group addressing information in the address table (<LonAddress>).
 *
 * LonAddressTableGroup holds group addressing data in the address table, used 
 * for multicast addressing. This structure also defines which group the node 
 * belongs to.
 */
#define LON_ADDRESS_GROUP_TYPE_MASK     0x80    /* 1 -> group   */
#define LON_ADDRESS_GROUP_TYPE_SHIFT    7
#define LON_ADDRESS_GROUP_TYPE_FIELD    TypeSize

#define LON_ADDRESS_GROUP_SIZE_MASK     0x7F    /* group size 1..63, or zero for open group */
#define LON_ADDRESS_GROUP_SIZE_SHIFT    0
#define LON_ADDRESS_GROUP_SIZE_FIELD    TypeSize

#define LON_ADDRESS_GROUP_DOMAIN_MASK   0x80    /* domain index */
#define LON_ADDRESS_GROUP_DOMAIN_SHIFT  7
#define LON_ADDRESS_GROUP_DOMAIN_FIELD  DomainMember

#define LON_ADDRESS_GROUP_MEMBER_MASK   0x7F
#define LON_ADDRESS_GROUP_MEMBER_SHIFT  0
#define LON_ADDRESS_GROUP_MEMBER_FIELD  DomainMember

#define LON_ADDRESS_GROUP_REPEAT_TIMER_MASK  0xF0    /* repeat timer, use LonRepeatTimer */
#define LON_ADDRESS_GROUP_REPEAT_TIMER_SHIFT 4
#define LON_ADDRESS_GROUP_REPEAT_TIMER_FIELD RepeatRetry

#define LON_ADDRESS_GROUP_RETRY_MASK    0x0F        /* retry count */
#define LON_ADDRESS_GROUP_RETRY_SHIFT   0
#define LON_ADDRESS_GROUP_RETRY_FIELD   RepeatRetry

#define LON_ADDRESS_GROUP_RECEIVE_TIMER_MASK    0xF0   /* receive timer, use LonReceiveTimer */
#define LON_ADDRESS_GROUP_RECEIVE_TIMER_SHIFT   4
#define LON_ADDRESS_GROUP_RECEIVE_TIMER_FIELD   ReceiveTransmit

#define LON_ADDRESS_GROUP_TRANSMIT_TIMER_MASK   0x0F  /* transmit timer, use LonTransmitTimer */
#define LON_ADDRESS_GROUP_TRANSMIT_TIMER_SHIFT  0
#define LON_ADDRESS_GROUP_TRANSMIT_TIMER_FIELD  ReceiveTransmit

typedef LON_STRUCT_BEGIN(LonAddressTableGroup) 
{
    LonByte      TypeSize;               /* contains type, size. Use the LON_ADDRESS_GROUP_* macros. */
    LonByte      DomainMember;           /* contains domain, member. Use the LON_ADDRESS_GROUP_* macros. */
    LonByte      RepeatRetry;            /* contains repeatTimer, retry. Use the LON_ADDRESS_GROUP_* macros. */
    LonByte      ReceiveTransmit;        /* contains receive and transmit timer. Use Lon_ADDRESS_GROUP_* macros. */
    LonGroupId   Group;                  /* the group identifier */
} LON_STRUCT_END(LonAddressTableGroup);

/*
 *  Typedef: LonAddressTableSubnetNode
 *  Holds subnet/node addressing information in the address table (<LonAddress>).
 *
 *  LonAddressTableSubnetNode holds subnet/node address information in the 
 *  address table (<LonAddress>), used for unicast addressing. 
 */
#define LON_ADDRESS_SN_DOMAIN_MASK      0x80        /* domain index */
#define LON_ADDRESS_SN_DOMAIN_SHIFT     7
#define LON_ADDRESS_SN_DOMAIN_FIELD     DomainNode

#define LON_ADDRESS_SN_NODE_MASK        0x7F        /* node ID */
#define LON_ADDRESS_SN_NODE_SHIFT       0
#define LON_ADDRESS_SN_NODE_FIELD       DomainNode

#define LON_ADDRESS_SN_REPEAT_TIMER_MASK    0xF0    /* repeat timer, use LonRepeatTimer */
#define LON_ADDRESS_SN_REPEAT_TIMER_SHIFT   4
#define LON_ADDRESS_SN_REPEAT_TIMER_FIELD   RepeatRetry

#define LON_ADDRESS_SN_RETRY_MASK       0x0F        /* retry count */
#define LON_ADDRESS_SN_RETRY_SHIFT      0
#define LON_ADDRESS_SN_RETRY_FIELD      RepeatRetry

typedef LON_STRUCT_BEGIN(LonAddressTableSubnetNode) 
{
    LON_ENUM(LonAddressType) Type;          /* should be LonAddressSubnetNode   */
    LonByte                  DomainNode;    /* contains domain, node. Use LON_ADDRESS_SN_* macros. */
    LonByte                  RepeatRetry;   /* contains repeat timer and retry. Use LON_ADDRESS_SN_* macros. */
    LON_ENUM(LonTransmitTimer) TransmitTimer;
    LonSubnetId             Subnet;
} LON_STRUCT_END(LonAddressTableSubnetNode);

/*
 *  Typedef: LonAddressTableBroadcast
 *  Holds broadcast addressing information in the address table (<LonAddress>).
 *
 *  LonAddressTableBroadcast holds broadcast addressing information in the 
 *  address table (<LonAddress>), used for multicast addressing. 
 */
#define LON_ADDRESS_BROADCAST_DOMAIN_MASK   0x80        /* domain index */
#define LON_ADDRESS_BROADCAST_DOMAIN_SHIFT  7
#define LON_ADDRESS_BROADCAST_DOMAIN_FIELD  DomainBacklog

#define LON_ADDRESS_BROADCAST_BACKLOG_MASK  0x3F        /* backlog. Use zero if unknown. */
#define LON_ADDRESS_BROADCAST_BACKLOG_SHIFT 0
#define LON_ADDRESS_BROADCAST_BACKLOG_FIELD DomainBacklog

#define LON_ADDRESS_BROADCAST_REPEAT_TIMER_MASK 0xF0    /* repeat timer, use LonRepeatTimer */
#define LON_ADDRESS_BROADCAST_REPEAT_SHIFT      4
#define LON_ADDRESS_BROADCAST_REPEAT_FIELD      RepeatRetry

#define LON_ADDRESS_BROADCAST_RETRY_MASK    0x0F        /* retry counts */
#define LON_ADDRESS_BROADCAST_RETRY_SHIFT   0
#define LON_ADDRESS_BROADCAST_RETRY_FIELD   RepeatRetry

typedef LON_STRUCT_BEGIN(LonAddressTableBroadcast) 
{
    LON_ENUM(LonAddressType) Type;           /* should be LonAddressBroadcast */
    LonByte                  DomainBacklog;  /* contains domain, backlog. Use LON_ADDRESS_BROADCAST_* macros. */
    LonByte                  RepeatRetry;    /* contains repeat timer and retry. Use LON_ADDRESS_BROADCAST_* macros instead. */
    LON_ENUM(LonTransmitTimer) TransmitTimer;
    LonSubnetId             Subnet;
} LON_STRUCT_END(LonAddressTableBroadcast);

/*
 *  Typedef: LonAddressTableTurnaround
 *  Holds turnaround address information in the address table (<LonAddress>).
 */
#define LON_ADDRESS_TURNAROUND_REPEAT_TIMER_MASK    0xF0    /* use LonRepeatTimer */
#define LON_ADDRESS_TURNAROUND_REPEAT_TIMER_SHIFT   4
#define LON_ADDRESS_TURNAROUND_REPEAT_TIMER_FIELD   RepeatRetry

#define LON_ADDRESS_TURNAROUND_RETRY_MASK           0x0F    /* retry count */
#define LON_ADDRESS_TURNAROUND_RETRY_SHIFT          0   
#define LON_ADDRESS_TURNAROUND_RETRY_FIELD          RepeatRetry

typedef LON_STRUCT_BEGIN(LonAddressTableTurnaround) 
{
    LON_ENUM(LonAddressType) Type;           /* should be LonAddressUnassigned */
    LonByte                  Turnaround;     /* 1: turnaround record. 0: not in use. */
    LonByte                  RepeatRetry;    /* contains repeat timer and retry. Use LON_ADDRESS_TURNAROUND_* macros. */
    LON_ENUM(LonTransmitTimer) TransmitTimer; 
} LON_STRUCT_END(LonAddressTableTurnaround);

/*
 * ******************************************************************************
 * SECTION: SYSTEM STRUCTURES
 * ******************************************************************************
 *
 *  This section contains definitions of system resources and structures, such 
 *  as the domain table or address table formats, and so on.
 */

/*
 *  Typedef: LonAddress
 *  Describes one record of the address table.
 */
typedef LON_UNION_BEGIN(LonAddress) 
{
    LonAddressTableGroup      Group;
    LonAddressTableSubnetNode SubnetNode;
    LonAddressTableBroadcast  Broadcast;
    LonAddressTableTurnaround Turnaround;
} LON_UNION_END(LonAddress);

/*
 *  Enumeration: LonDomainLength
 *  Encodes the length of the domain.
 *
 *  This enumeration encodes the length of the domain.
 */
typedef LON_ENUM_BEGIN(LonDomainLength) 
{
    /*  0 */ LonDomainLength_0  = 0,
    /*  1 */ LonDomainLength_1  = 1,
    /*  3 */ LonDomainLength_3  = 3,
    /*  6 */ LonDomainLength_6  = 6
} LON_ENUM_END(LonDomainLength);

/*
 *  Typedef: LonDomain
 *  Format for a single domain table record.
 */
#define LON_DOMAIN_NONCLONE_MASK    0x80
#define LON_DOMAIN_NONCLONE_SHIFT   7
#define LON_DOMAIN_NONCLONE_FIELD   NodeClone

#define LON_DOMAIN_NODE_MASK        0x7F
#define LON_DOMAIN_NODE_SHIFT       0
#define LON_DOMAIN_NODE_FIELD       NodeClone

#define LON_DOMAIN_INVALID_MASK     0x80
#define LON_DOMAIN_INVALID_SHIFT    7
#define LON_DOMAIN_INVALID_FIELD    InvalidIdLength

#define LON_DOMAIN_ID_LENGTH_MASK   0x07
#define LON_DOMAIN_ID_LENGTH_SHIFT  0
#define LON_DOMAIN_ID_LENGTH_FIELD  InvalidIdLength

#define LON_DOMAIN_OMA_MASK      0x18
#define LON_DOMAIN_OMA_SHIFT     3
#define LON_DOMAIN_OMA_FIELD     InvalidIdLength

#define LON_DOMAIN_DHCP_MASK      0x20
#define LON_DOMAIN_DHCP_SHIFT     5
#define LON_DOMAIN_DHCP_FIELD     InvalidIdLength

#define LON_DOMAIN_LS_ENHANCED_MODE_MASK      0x40
#define LON_DOMAIN_LS_ENHANCED_MODE_SHIFT     6
#define LON_DOMAIN_LS_ENHANCED_MODE_FIELD     InvalidIdLength

// All option bits in Domain structure (OMA, DHCP, and LS ENHANCED MODE)
#define LON_DOMAIN_OPTION_BITS_MASK      LON_DOMAIN_OMA_MASK | LON_DOMAIN_DHCP_MASK | LON_DOMAIN_LS_ENHANCED_MODE_MASK
#define LON_DOMAIN_OPTION_BITS_SHIFT     3
#define LON_DOMAIN_OPTION_BITS_FIELD     InvalidIdLength

typedef LON_STRUCT_BEGIN(LonDomain) 
{
    LonDomainId      Id;         
    LonSubnetId      Subnet;
    LonByte          NodeClone;  /* contains non-clone, node. Use LON_DOMAIN_* macros. */
    LonByte          InvalidIdLength;   /* use LON_DOMAIN_INVALID_*, LON_DOMAIN_ID_LENGTH_*, */
                                        /* LON_DOMAIN_OMA_*, LON_DOMAIN_DHCP_*, LON_DOMAIN_LS_ENHANCED_MODE_* macros */
    LonAuthenticationKey Key;
} LON_STRUCT_END(LonDomain);

/*
 *  Enumeration: LonNvDirection
 *  Encodes the direction of a network variable.
 *
 *  This enumeration encodes the direction of a network variable.
 */
typedef LON_ENUM_BEGIN(LonNvDirection) 
{
    /*  0 */ LonNvDirectionIsInput  = 0,
    /*  1 */ LonNvDirectionIsOutput = 1,
} LON_ENUM_END(LonNvDirection);

/*
 *  Typedef: LonNvConfig
 *  The network variable configuration structure for legacy devices.
 *
 *  LonNvConfig is used to store network variable configuration
 *  in legacy devices.  IzoT uses LonNvEcsConfig.
 */
#define LON_NV_PRIORITY_MASK    0x80        /* use LonBool */
#define LON_NV_PRIORITY_SHIFT   7
#define LON_NV_PRIORITY_FIELD   SelhiDirPrio

#define LON_NV_DIRECTION_MASK   0x40        /* use LonNvDirection */
#define LON_NV_DIRECTION_SHIFT  6
#define LON_NV_DIRECTION_FIELD  SelhiDirPrio

#define LON_NV_SELHIGH_MASK     0x3F
#define LON_NV_SELHIGH_SHIFT    0
#define LON_NV_SELHIGH_FIELD    SelhiDirPrio

#define LON_NV_TURNAROUND_MASK  0x80        /* use LonBool */
#define LON_NV_TURNAROUND_SHIFT 7
#define LON_NV_TURNAROUND_FIELD Attributes

#define LON_NV_SERVICE_MASK     0x60        /* use LonServiceType */
#define LON_NV_SERVICE_SHIFT    5
#define LON_NV_SERVICE_FIELD    Attributes

#define LON_NV_AUTHENTICATION_MASK  0x10    /* use LonBool */
#define LON_NV_AUTHENTICATION_SHIFT 4
#define LON_NV_AUTHENTICATION_FIELD Attributes

#define LON_NV_ADDRESS_MASK     0x0F
#define LON_NV_ADDRESS_SHIFT    0
#define LON_NV_ADDRESS_FIELD    Attributes

typedef LON_STRUCT_BEGIN(LonNvConfig) 
{
    LonByte  SelhiDirPrio;   /* contains selector-high, direction, priority. Use LON_NV_* macros. */
    LonByte  SelectorLow;
    LonByte  Attributes;     /* contains turnaround, service, authentication, and address table index. Use LON_NV_* macros. */
} LON_STRUCT_END(LonNvConfig);

/*
*  Enumeration: LonSelectionType
*  Literals for the ECS selection type.
*
*/

typedef LON_ENUM_BEGIN(LonSelectionType) 
{
    LonSelectionSelectorOnly,      /* 0 normal:  select as long as selector matches */
    LonSelectionSelectorAndSource, /* 1: select if both selector and source match */
    LonSelectionNoSelection,       /* 2: do not do NV selection; reserved for poll-only inputs */
} LON_ENUM_END(LonSelectionType);

/*
 *  Typedef: LonNvEcsConfig
 *  The network variable configuration structure for use with ECS devices.
 *
 *  LonNvEcsConfig is used to store network variable configuration
 *  in Extended Command Set (ECS) devices, such as an IzoT device.
 */

#define LON_NV_ECS_PRIORITY_MASK  0x80    /* use LonBool */
#define LON_NV_ECS_PRIORITY_SHIFT 7 
#define LON_NV_ECS_PRIORITY_FIELD SelhiDirPrio

#define LON_NV_ECS_DIRECTION_MASK  0x40    /* use LonNvDirection */
#define LON_NV_ECS_DIRECTION_SHIFT 6
#define LON_NV_ECS_DIRECTION_FIELD SelhiDirPrio

#define LON_NV_ECS_SELHIGH_MASK  0x3F    
#define LON_NV_ECS_SELHIGH_SHIFT 0
#define LON_NV_ECS_SELHIGH_FIELD SelhiDirPrio

#define LON_NV_ECS_TURNAROUND_MASK  0x80    /* use LonBool */
#define LON_NV_ECS_TURNAROUND_SHIFT 7
#define LON_NV_ECS_TURNAROUND_FIELD Attributes1

#define LON_NV_ECS_AUTHENTICATION_MASK  0x40    /* use LonBool */
#define LON_NV_ECS_AUTHENTICATION_SHIFT 6
#define LON_NV_ECS_AUTHENTICATION_FIELD Attributes1

#define LON_NV_ECS_WRITE_BY_INDEX_MASK  0x20    /* use LonBool */
#define LON_NV_ECS_WRITE_BY_INDEX_SHIFT 5
#define LON_NV_ECS_WRITE_BY_INDEX_FIELD Attributes1

#define LON_NV_ECS_REMOTE_NM_AUTH_MASK  0x10    /* use LonBool */
#define LON_NV_ECS_REMOTE_NM_AUTH_SHIFT 4
#define LON_NV_ECS_REMOTE_NM_AUTH_FIELD Attributes1

#define LON_NV_ECS_RESP_SELECTION_MASK  0x0C    /* use LonSelectionType */
#define LON_NV_ECS_RESP_SELECTION_SHIFT 2
#define LON_NV_ECS_RESP_SELECTION_FIELD Attributes1

#define LON_NV_ECS_UNUSED_MBZ_MASK 0x03    
#define LON_NV_ECS_UNUSED_MBZ_SHIFT 0
#define LON_NV_ECS_UNUSED_MBZ_FIELD Attributes1

#define LON_NV_ECS_READ_BY_INDEX_MASK  0x80    /* use LonBool */
#define LON_NV_ECS_READ_BY_INDEX_SHIFT 7
#define LON_NV_ECS_READ_BY_INDEX_FIELD Attributes2

#define LON_NV_ECS_SERVICE_MASK 0x60        /* use LonServiceType */
#define LON_NV_ECS_SERVICE_SHIFT 5
#define LON_NV_ECS_SERVICE_FIELD Attributes2

#define LON_NV_ECS_REQUEST_SELECTION_MASK  0x18    /* use LonSelectionType */
#define LON_NV_ECS_REQUEST_SELECTION_SHIFT 3
#define LON_NV_ECS_REQUEST_SELECTION_FIELD Attributes2

#define LON_NV_ECS_UPDATE_SELECTION_MASK  0x06    /* use LonSelectionType */
#define LON_NV_ECS_UPDATE_SELECTION_SHIFT 1
#define LON_NV_ECS_UPDATE_SELECTION_FIELD Attributes2

#define LON_NV_ECS_SOURCE_SELECTION_MASK  0x01    /* use LonBool */
#define LON_NV_ECS_SOURCE_SELECTION_SHIFT 0
#define LON_NV_ECS_SOURCE_SELECTION_FIELD Attributes2

typedef LON_STRUCT_BEGIN(LonNvEcsConfig) 
{
    LonByte  SelhiDirPrio;   /* contains selector-high, direction, priority. Use LON_NV_ECS_* macros. */
    LonByte  SelectorLow;
    LonByte  Attributes1;    /* contains turnaround, authentication write-by-index, remote-nm-auth, response-selection. Use LON_NV_* macros. */
    LonByte  Attributes2;    /* contains read-by-index, service, request-selection, update-selection, source-selection-only. Use LON_NV_ECS_* macros. */
    LonWord  AddressIndex;   /* Address table index */
    LonWord  NvIndex;        /* index of remote network variable */
} LON_STRUCT_END(LonNvEcsConfig);

/*
 *  Typedef: LonAliasConfig
 *  Defines a network variable alias for legacy devices.
 *
 */
typedef LON_STRUCT_BEGIN(LonAliasConfig) 
{
    LonNvConfig               Alias;
    LonByte                   Primary;
    LonWord                   HostPrimary;   /* iff primary is 0xFF */
} LON_STRUCT_END(LonAliasConfig);

/*
 *  Typedef: LonAliasEcsConfig
 *  Defines a network variable alias in ECS devices.
 *
 *  Used for Extended Command Set (ECS) devices, such as an IzoT device.
 */
typedef LON_STRUCT_BEGIN(LonAliasEcsConfig) 
{
    LonNvEcsConfig               Alias;
    LonWord                      Primary;
} LON_STRUCT_END(LonAliasEcsConfig);

/*
 *  Typedef: LonDirectModeTransceiver
 *  Holds direct-mode transceiver parameters.
 */
#define LON_DIRECT_XCVR_CD_MASK             0x80    /* collision-detect */   
#define LON_DIRECT_XCVR_CD_SHIFT            7
#define LON_DIRECT_XCVR_CD_FIELD            Parameter_1

#define LON_DIRECT_XCVR_BST_MASK            0x60    /* bit-sync-threshold */
#define LON_DIRECT_XCVR_BST_SHIFT           5
#define LON_DIRECT_XCVR_BST_FIELD           Parameter_1

#define LON_DIRECT_XCVR_FILTER_MASK         0x18    /* filter */
#define LON_DIRECT_XCVR_FILTER_SHIFT        3
#define LON_DIRECT_XCVR_FILTER_FIELD        Parameter_1

#define LON_DIRECT_XCVR_HYSTERESIS_MASK     0x07    /* hysteresis */
#define LON_DIRECT_XCVR_HYSTERESIS_SHIFT    0
#define LON_DIRECT_XCVR_HYSTERESIS_FIELD    Parameter_1

#define LON_DIRECT_XCVR_CDTEP_MASK          0xFC    /* CD to end packet */
#define LON_DIRECT_XCVR_CDTEP_SHIFT         2
#define LON_DIRECT_XCVR_CDTEP_FIELD         Parameter_2

#define LON_DIRECT_XCVR_CDTAIL_MASK         0x02    /* CD tail */
#define LON_DIRECT_XCVR_CDTAIL_SHIFT        1
#define LON_DIRECT_XCVR_CDTAIL_FIELD        Parameter_2

#define LON_DIRECT_XCVR_CDPREAMBLE_MASK     0x01    /* CD preamble */
#define LON_DIRECT_XCVR_CDPREAMBLE_SHIFT    0
#define LON_DIRECT_XCVR_CDPREAMBLE_FIELD    Parameter_2

typedef LON_STRUCT_BEGIN(LonDirectModeTransceiver) 
{
    LonByte      Parameter_1;    /* contains collision-detect, bit-sync-threshold, filter, and hysteresis. Use LON_DIRECT_XCVR_* macros. */
    LonByte      Parameter_2;    /* contains cd-to-end-packet, cd-tail, cd-preamble. Use LON_DIRECT_XCVR_* macros. */
} LON_STRUCT_END(LonDirectModeTransceiver);

/*
 *  Typedef: LonNvDefinition
 *  Network Variable Definition.  
 *
 * The LonNvDefinition structure is used to define the attributes of a network 
 * variable.  This is used by the LonTalk Interface Developer-generated code 
 * to register static network variables with the IzoT protocol stack, 
 * and is also used to retrieve information about static or dynamic network 
 * variables.
 *
 * Used by the LonTalk Interface Developer-generated code to register network 
 * variables, by the IzoT event <LonNvAdded>, and returned by the IzoT Device 
 * Stack API function <LonQueryNvType>. 
 *
 */

/*
 * Use the LON_NV_* macros to form a bitmask that defines the attributes of a 
 * network variable.  These macros are used by the <flags> field in <LonNvDefinition>.
 */
#define LON_NV_NONE                0x0000 /* No flags specified. */
#define LON_NV_CONFIG_CLASS        0x0001 /* Config class NV.  Config NVs are 
                                           * kept persistently, and can implement 
                                           * a CP (dependent on the network 
                                           * variable's self documentation string). */
#define LON_NV_AUTH_CONFIG         0x0002 /* The authentication attribute is 
                                           * configurable. */
#define LON_NV_PRIORITY_CONFIG     0x0004 /* The priority attribute is configurable. */
#define LON_NV_SERVICE_CONFIG      0x0008 /* The service type attribute is 
                                           * configurable. */
#define LON_NV_OFFLINE             0x0010 /* Network managers should only change 
                                           * this value when the device is offline. */
#define LON_NV_POLLED              0x0020 /* This is either a polling input or a 
                                           * polled output. */
#define LON_NV_SYNC                0x0040 /* A synchronous NV. */
#define LON_NV_CHANGEABLE          0x0080 /* The network variable type is changeable. */
#define LON_NV_PRIORITY            0x0100 /* Default to priority. */
#define LON_NV_AUTHENTICATED       0x0200 /* Default to authenticated. */
#define LON_NV_ACKD                0x0400 /* Default to acknowledged service. */
#define LON_NV_UNACKD_RPT          0x0800 /* Default to unacknowledged repeat service. */
#define LON_NV_UNACKD              0x1000 /* Default to unacknowledged service. */
#define LON_NV_IS_OUTPUT           0x8000 /* The NV is an output network variable.  
                                           * If not specified, the NV is an input. */

/*
 *  Macro: LON_NV_RATE_UNKNOWN
 *  The max or mean network variable rate is unknown or unspecified.
 *
 *  Use this value rather than an encoded rate for the MaxRate or MeanRate
 *  field of the <LonNvDefinition> structure to indicate that the rate
 *  is unknown.
 */
#define LON_NV_RATE_UNKNOWN     0 

/*
 *  Macro: LON_NV_DEFINITION_CURRENT_VERSION
 *  The current version of the LonNvDefinition structure.
 *
 */
#define LON_NV_DEFINITION_CURRENT_VERSION 0

typedef LON_STRUCT_BEGIN(LonNvDefinition)
{
    unsigned char Version;          /* If the IzoT protocol stack does 
                                       not recognize the version, it will be 
                                       rejected.  The current version is 
                                       LON_NV_DEFINITION_CURRENT_VERSION. */
    volatile void const *PValue;    /* Pointer to the network variable value. */
    unsigned char DeclaredSize;        /* The declared size of the NV (1 to 228).  
                                       This is also the initial size and the 
                                       maximum size. */
    unsigned short SnvtId;          /* Specifies the type of NV if it is a 
                                       SNVT (1-250). A non-standard network 
                                       variable type will have SnvtId = 0. */
    unsigned short ArrayCount;      /* Array Count (0 to 4096).  A 0 
                                       indicates that the network variable is 
                                       not an array. */
    unsigned Flags;                 /* Bit flags describing attributes of the 
                                       network variable.  From a combination 
                                       of the LON_NV_* flags. */
    const char *Name;               /* Network variable name.  Limited to 16 
                                       bytes base name plus an array 
                                       designator of [dddd] where dddd is a 
                                       one to four digit decimal number from 
                                       0 to 4095. */
    const char *SdString;           /* Self Doc String.  Can be null.  String 
                                       length is 0 to 1023 characters. */
    unsigned char MaxRate;            /* Encoded maximum rate (0 to 127, or 255).  
                                       Set to LON_NV_RATE_UKNOWN if not 
                                       specified. */
    unsigned char MeanRate;         /* Encoded rate(0 to 127, or 255).  Set 
                                       to LON_NV_RATE_UKNOWN if not specified. */
} LON_STRUCT_END(LonNvDefinition);

/*
 *  Typedef: LonConfigData
 *  The configuration data structure.
 */
#define LON_CONFIG_COMM_CLOCK_MASK      0xF8    /* communications clock rate */
#define LON_CONFIG_COMM_CLOCK_SHIFT     3
#define LON_CONFIG_COMM_CLOCK_FIELD     Clock

#define LON_CONFIG_INPUT_CLOCK_MASK     0x07    /* input clock */
#define LON_CONFIG_INPUT_CLOCK_SHIFT    0
#define LON_CONFIG_INPUT_CLOCK_FIELD    Clock

#define LON_CONFIG_COMM_TYPE_MASK       0xE0    /* communications type */
#define LON_CONFIG_COMM_TYPE_SHIFT      5
#define LON_CONFIG_COMM_TYPE_FIELD      CommConfiguration

#define LON_CONFIG_COMM_PINDIR_MASK     0x1F    /* pin direction */
#define LON_CONFIG_COMM_PINDIR_SHIFT    0
#define LON_CONFIG_COMM_PINDIR_FIELD    CommConfiguration

#define LON_CONFIG_NONGRPRCV_MASK       0xF0    /* non-group receive timer, use <LonNonGroupReceiveTimer> */
#define LON_CONFIG_NONGRPRCV_SHIFT      4 
#define LON_CONFIG_NONGRPRCV_FIELD      Config_1

#define LON_CONFIG_NMAUTH_MASK          0x08    /* network management authentication */
#define LON_CONFIG_NMAUTH_SHIFT         3
#define LON_CONFIG_NMAUTH_FIELD         Config_1

#define LON_CONFIG_PREEMPT_MASK         0x07    /* pre-emption timeout */
#define LON_CONFIG_PREEMPT_SHIFT        0
#define LON_CONFIG_PREEMPT_FIELD        Config_1

typedef LON_STRUCT_BEGIN(LonConfigData) 
{
    LonWord         ChannelId;
    LonLocationId   Location;
    LonByte         Clock;              /* contains input clock, communications clock. Use LON_CONFIG_* macros. */
    LonByte         CommConfiguration;  /* contains communications type, communications pin direction. Use LON_CONFIG_* macros. */
    LonByte         PreambleLength;
    LonByte         PacketCycle;
    LonByte         Beta2Control;
    LonByte         TransmitInterpacket;
    LonByte         ReceiveInterpacket;
    LonByte         NodePriority;
    LonByte         ChannelPriorities;
    LON_UNION_BEGIN(CommunicationParameters) 
    {
        LonTransceiverParameters    TransceiverParameters;
        LonDirectModeTransceiver    DirectModeParameters;
    } LON_UNION_END(CommunicationParameters);
    LonByte          Config_1;           /* contains pre-emption timeout, network management authentication, non-group receive timer. Use LON_CONFIG_* macros. */
} LON_STRUCT_END(LonConfigData);


#define LON_READONLY_CHECKSUM_MASK         0xF0    /* contains checksum for Unique Node ID */
#define LON_READONLY_CHECKSUM_SHIFT        4
#define LON_READONLY_CHECKSUM_FIELD        CheckSumMinorNum

#define LON_READONLY_MINORNUM_MASK         0x0F    /* minorModelNum */
#define LON_READONLY_MINORNUM_SHIFT        0
#define LON_READONLY_MINORNUM_FIELD        CheckSumMinorNum

#define LON_READONLY_RW_PROTECT_MASK       0x80    /* read+write protect flag */
#define LON_READONLY_RW_PROTECT_SHIFT      7
#define LON_READONLY_RW_PROTECT_FIELD      ReadOnly_1

#define LON_READONLY_RUN_UNCONFIG_MASK     0x40    /* runWhenUnconf */
#define LON_READONLY_RUN_UNCONFIG_SHIFT    6
#define LON_READONLY_RUN_UNCONFIG_FIELD    ReadOnly_1

#define LON_READONLY_NVCOUNT_MASK          0x3F    /* nvCount */
#define LON_READONLY_NVCOUNT_SHIFT         0
#define LON_READONLY_NVCOUNT_FIELD         ReadOnly_1

#define LON_READONLY_NV_PROCESSINGOFF_MASK          0x80    /* nvProcessingOff */
#define LON_READONLY_NV_PROCESSINGOFF_SHIFT         7
#define LON_READONLY_NV_PROCESSINGOFF_FIELD         ReadOnly_2

#define LON_READONLY_TWO_DOMAINS_MASK               0x40    /* twoDomains */
#define LON_READONLY_TWO_DOMAINS_SHIFT              6
#define LON_READONLY_TWO_DOMAINS_FIELD              ReadOnly_2

#define LON_READONLY_RESERVED2_MASK                 0x20    /* r2 */
#define LON_READONLY_RESERVED2_SHIFT                5
#define LON_READONLY_RESERVED2_FIELD                ReadOnly_2

#define LON_READONLY_RESERVED3_MASK                 0x10    /* r3 */
#define LON_READONLY_RESERVED3_SHIFT                4
#define LON_READONLY_RESERVED3_FIELD                ReadOnly_2

#define LON_READONLY_MSG_PROCESS_MASK               0x08    /* msgProcess */
#define LON_READONLY_MSG_PROCESS_SHIFT              3
#define LON_READONLY_MSG_PROCESS_FIELD              ReadOnly_2

#define LON_READONLY_NODE_STATE_MASK                0x07    /* nodeState */
#define LON_READONLY_NODE_STATE_SHIFT               0
#define LON_READONLY_NODE_STATE_FIELD               ReadOnly_2

#define LON_READONLY_ADDRESS_CNT_MASK               0xF0    /* # of entries in address table  */
#define LON_READONLY_ADDRESS_CNT_SHIFT              4
#define LON_READONLY_ADDRESS_CNT_FIELD              ReadOnly_3

#define LON_READONLY_RESERVED5_MASK                 0x0F    /* r5 */
#define LON_READONLY_RESERVED5_SHIFT                0
#define LON_READONLY_RESERVED5_FIELD                ReadOnly_3

#define LON_READONLY_RESERVED6_MASK                 0xF0    /* r6  */
#define LON_READONLY_RESERVED6_SHIFT                4
#define LON_READONLY_RESERVED6_FIELD                ReadOnly_4

#define LON_READONLY_REC_TRANSCNT_MASK              0x0F    /* receiveTransCnt */
#define LON_READONLY_REC_TRANSCNT_SHIFT             0
#define LON_READONLY_REC_TRANSCNT_FIELD             ReadOnly_4

#define LON_READONLY_OUTBUF_SIZE_MASK               0xF0    /* appOutBufSize */
#define LON_READONLY_OUTBUF_SIZE_SHIFT              4
#define LON_READONLY_OUTBUF_SIZE_FIELD              AppBufSize

#define LON_READONLY_INBUF_SIZE_MASK                0x0F    /* appInBufSize */
#define LON_READONLY_INBUF_SIZE_SHIFT               0
#define LON_READONLY_INBUF_SIZE_FIELD               AppBufSize

#define LON_READONLY_NW_OUTBUF_SIZE_MASK            0xF0    /* nwOutBufSize  */
#define LON_READONLY_NW_OUTBUF_SIZE_SHIFT           4
#define LON_READONLY_NW_OUTBUF_SIZE_FIELD           NwBufSize

#define LON_READONLY_NW_INBUF_SIZE_MASK             0x0F    /* nwInBufSize */
#define LON_READONLY_NW_INBUF_SIZE_SHIFT            0
#define LON_READONLY_NW_INBUF_SIZE_FIELD            NwBufSize

#define LON_READONLY_NW_OUT_PRICNT_MASK             0xF0    /* nwOutBufPriCnt  */
#define LON_READONLY_NW_OUT_PRICNT_SHIFT            4
#define LON_READONLY_NW_OUT_PRICNT_FIELD            PriCnt

#define LON_READONLY_OUT_PRICNT_MASK                0x0F    /* appOutBufPriCnt */
#define LON_READONLY_OUT_PRICNT_SHIFT               0
#define LON_READONLY_OUT_PRICNT_FIELD               PriCnt

#define LON_READONLY_OUTBUF_CNT_MASK                0xF0    /* appOutBufCnt  */
#define LON_READONLY_OUTBUF_CNT_SHIFT               4
#define LON_READONLY_OUTBUF_CNT_FIELD               AppBufCnt

#define LON_READONLY_INBUF_CNT_MASK                 0x0F    /* appInBufCnt */
#define LON_READONLY_INBUF_CNT_SHIFT                0
#define LON_READONLY_INBUF_CNT_FIELD                AppBufCnt

#define LON_READONLY_NW_OUTBUF_CNT_MASK             0xF0    /* nwOutBufCnt  */
#define LON_READONLY_NW_OUTBUF_CNT_SHIFT            4
#define LON_READONLY_NW_OUTBUF_CNT_FIELD            NwBufCnt

#define LON_READONLY_NW_INBUF_CNT_MASK              0x0F    /* nwInBufCnt */
#define LON_READONLY_NW_INBUF_CNT_SHIFT             0
#define LON_READONLY_NW_INBUF_CNT_FIELD             NwBufCnt

#define LON_READONLY_RESERVED7_MASK                 0xFC    /* R7  */
#define LON_READONLY_RESERVED7_SHIFT                4
#define LON_READONLY_RESERVED7_FIELD                ReadOnly_5

#define LON_READONLY_TX_BY_ADDRESS_MASK             0x02    /* txByAddress */
#define LON_READONLY_TX_BY_ADDRESS_SHIFT            1
#define LON_READONLY_TX_BY_ADDRESS_FIELD            ReadOnly_5

#define LON_READONLY_RESERVED8_MASK                 0x01    /* r8 */
#define LON_READONLY_RESERVED8_SHIFT                0
#define LON_READONLY_RESERVED8_FIELD                ReadOnly_5

#define LON_READONLY_RESERVED9_MASK                 0xC0    /* r9 */
#define LON_READONLY_RESERVED9_SHIFT                6
#define LON_READONLY_RESERVED9_FIELD                ReadOnly_6

#define LON_READONLY_ALIAS_CNT_MASK                 0x3F    /* aliasCnt */
#define LON_READONLY_ALIAS_CNT_SHIFT                0
#define LON_READONLY_ALIAS_CNT_FIELD                ReadOnly_6

#define LON_READONLY_MSG_TAG_CNT_MASK              0x0F    /* msgTagCnt */
#define LON_READONLY_MSG_TAG_CNT_SHIFT             0
#define LON_READONLY_MSG_TAG_CNT_FIELD             ReadOnly_7

#define LON_READONLY_RESERVED10_MASK               0x0F    /* r10 */
#define LON_READONLY_RESERVED10_SHIFT              0
#define LON_READONLY_RESERVED10_FIELD              ReadOnly_7

#define LON_READONLY_DMF_MASK                      0x80    /* dmf */
#define LON_READONLY_DMF_SHIFT                     0
#define LON_READONLY_DMF_FIELD                     ReadOnly_8

#define LON_READONLY_RESERVED11_MASK               0x7F    /* RESERVED11 */
#define LON_READONLY_RESERVED11_SHIFT              0
#define LON_READONLY_RESERVED11_FIELD              ReadOnly_8

typedef LON_STRUCT_BEGIN(LonReadOnlyData) 
{
    LonUniqueId  UniqueNodeId;      /* 48-bit unique ID of Neuron Chip or Smart Transceiver              */
    LonByte  ModelNum;              /* Model Number for Ref. Impl.                                       */
    LonByte  CheckSumMinorNum;      /* contains checksum for Unique Node ID and minorModelNum (0-128).   */
                                    /* Use LON_CONFIG_* macros.                                          */
    LonByte  NvFixed[2];            /* Location of nv fixed table.                                       */
    LonByte  ReadOnly_1;            /* Contains:  (Use LON_CONFIG_* macros. )                            */
                                    /* readWriteProtect , 1,       read+write protect flag.              */
                                    /* runWhenUnconf    , 1,       1=> Application runs.                 */
                                    /* nvCount          , 6,       0 for reference implementation.       */
    LonByte  SnvtStruct[2];         /* 0xFFFF for reference implementation.                              */
    LonProgramId ProgramId;         /* Program ID string (array of 8 bytes)                              */
    LonByte  ReadOnly_2;            /* Contains:  (Use LON_READONLY_* macros. )                          */
                                    /* nvProcessingOff  , 1,       Must be one for NodeUtil.             */
                                    /* twoDomains       , 1,       1 if node is in 2 domains.            */
                                    /* r2               , 1,       explicitAddr not used in Ref. Impl.   */
                                    /* r3               , 1,       Unused.                               */
                                    /* msgProcess       , 1,       1 means explicit messages processed.  */
                                    /* nodeState        , 3,       Node State. See eia709_1.h            */
    LonByte ReadOnly_3;             /* Contains: (Use LON_READONLY_* macros. )                           */
                                    /* # of entries in address table (AddressCn).                        */
                                    /* r5               , 4       Unused.                                */
    LonByte ReadOnly_4;             /* Contains:  (Use LON_READONLY_* macros. )                          */
                                    /* r6               , 4,       Unused.                               */
                                    /* receiveTransCnt  , 4        RR Cnt = this field + 1               */
    LonByte AppBufSize;             /* appOutBufSize   , 4,        Special Size Encoding.                */
                                    /* appInBufSize     , 4        Special Size Encoding.                */
    LonByte NwBufSize;              /* nwOutBufSize, 4,            Special Size Encoding.                */
                                    /* nwInBufSize      , 4        Special Size Encoding.                */
    LonByte PriCnt;                 /* nwOutBufPriCnt   , 4,       Special Count Enconding.              */
                                    /* appOutBufPriCnt  , 4        Special Count Enconding.              */
    LonByte AppBufCnt;              /* appOutBufCnt, 4,            Special Count Enconding.              */
                                    /* appInBufCnt      , 4        Special Count Enconding.              */
    LonByte NwBufCnt;               /* nwOutBufCnt, 4,             Special Count Enconding.              */
                                    /* nwInBufCnt       , 4        Special Count Enconding.              */
    LonByte Reserved0;              /* Unused                                                            */
    LonByte Reserved1[2];           /* Unused.                                                           */
    LonByte Reserved2[3];           /* Unused.                                                           */
    LonByte ReadOnly_5;             /* Contains:  (Use LON_READONLY_* macros. )                          */
                                    /* R7              , 6,       Unused.                                */
                                    /* txByAddress      , 1,      0 in reference implementation.         */
                                    /* r8               , 1)      Unused.                                */
    LonByte ReadOnly_6;             /* r9               , 2,      Unused.                                */
                                    /* aliasCnt          , 6)     0 in reference implementation.         */
    LonByte ReadOnly_7;             /* msgTagCnt, 4,      0 in reference implementation.                 */
                                    /* r10              , 4)       Unused.                               */
    LonByte Reserved3[3];           /* Unused.                                                           */
    LonByte NvCount;
    LonByte AliasCount;
    LonByte Snvt2Hi;
    LonByte Snvt2Lo;
    LonByte ReadOnly_8;             /* dmf  , 1,                                                         */
                                    /* r11  , 7                                                          */
} LON_STRUCT_END(LonReadOnlyData);

/*
 *  Typedef: LonStatus
 *  Holds node status and statistics.
 */
typedef LON_STRUCT_BEGIN(LonStatus) 
{
    LonWord                 TransmitErrors;
    LonWord                 TransactionTimeouts;
    LonWord                 ReceiveTransactionsFull;
    LonWord                 LostMessages;
    LonWord                 MissedMessages;
    LON_ENUM(LonResetCause) ResetCause;
    LON_ENUM(LonNodeState)  NodeState;
    LonByte                 VersionNumber;
    LON_ENUM(LonSystemError) ErrorLog;
    LON_ENUM(LonNeuronModel) ModelNumber;
} LON_STRUCT_END(LonStatus);

/*
 * ******************************************************************************
 * SECTION: MESSAGE CODES
 * ******************************************************************************
 *
 *  This section defines message codes and utilities for dealing with message 
 *  codes.
 */

/* 
 *  Enumeration: LonNmMessageCode
 *  Message codes for network management and diagnostic classes of messages.
 */
typedef LON_ENUM_BEGIN(LonNmMessageCode) 
{
    /* codes for network diagnostic commands */
    LonNdQueryStatus                   = 0x51,
    LonNdProxy                         = 0x52,
    LonNdClearStatus                   = 0x53,
    LonNdQueryXcvr                     = 0x54,
    LonNdQueryStatusFlexDomain         = 0x56,

    /* codes for network management commands */
    LonNmExpanded                      = 0x60,
    LonNmQueryId                       = 0x61,
    LonNmRespondToQuery                = 0x62,
    LonNmUpdateDomain                  = 0x63,
    LonNmLeaveDomain                   = 0x64,
    LonNmUpdateKey                     = 0x65,
    LonNmUpdateAddr                    = 0x66,
    LonNmQueryAddr                     = 0x67,
    LonNmQueryNvConfig                 = 0x68,
    LonNmUpdateGroupAddr               = 0x69,
    LonNmQueryDomain                   = 0x6A,
    LonNmUpdateNvConfig                = 0x6B,
    LonNmSetNodeMode                   = 0x6C,
    LonNmReadMemory                    = 0x6D,
    LonNmWriteMemory                   = 0x6E,
    LonNmChecksumRecalculation         = 0x6F,
    LonNmWink                          = 0x70,
    LonNmInstall                       = LonNmWink, /* See <LonInstallCommand> */
    LonNmAppCommand                    = LonNmWink,
    LonNmMemoryRefresh                 = 0x71,
    LonNmQuerySnvt                     = 0x72,
    LonNmNvFetch                       = 0x73,
    LonNmDeviceEscape                  = 0x7D,
    LonNmRouterEscape                  = 0x7E,
    LonNmServicePin                    = 0x7F
} LON_ENUM_END(LonNmMessageCode);

/*
 *  Enumeration: LonInstallCommand
 *  Extended installation commands for devices that use SI data version 2. SI 
 *  data version 2 is required for any device that supports dynamic network 
 *  variables. Used by <LonNmInstallRequest>.
 */
typedef LON_ENUM_BEGIN(LonInstallCommand) 
{
    LonInstallWink              = 0,    /* Basic application wink                     */
    LonInstallQueryNvInfo       = 4,    /* Query network variable information         */
    LonInstallQueryNodeInfo     = 5,    /* Query node self-documentation information  */
} LON_ENUM_END(LonInstallCommand);

/*
 *  Enumeration: LonNvInfoType
 *  Types of network variable information that can be queried using 
 *  *LonInstallQueryNvInfo*. Used by <LonNmInstallRequest> when *Command* is 
 *  set to *LonInstallQueryNvInfo*. 
 */
typedef LON_ENUM_BEGIN(LonNvInfoType) 
{
    LonNvInfoDescriptor         = 0,    /* Query NV description (LonNmInstallResponse.NvDescriptor) */
    LonNvInfoRateEstimate       = 1,    /* Query NV rate estimates (LonNmInstallResponse.NvRate) */
    LonNvInfoName               = 2,    /* Query NV Name (LonNmInstallResponse.NvName) */
    LonNvInfoSdText             = 3,    /* Query NV self-documentation string (LonNmInstallResponse.NvSd) */
    LonNvInfoSnvtIndex          = 4,    /* Query NV SNVT index (LonNmInstallResponse.SnvtTypeIndex) */
} LON_ENUM_END(LonNvInfoType);

/*
 *  Enumeration: LonNodeInfoType
 *  Types of node information that can be queried using *LonInstallQueryNodeInfo*.
 *  Used by <LonNmInstallRequest> when *Command* is set to 
 *  *LonInstallQueryNodeInfo*. 
 */
typedef LON_ENUM_BEGIN(LonNodeInfoType) 
{
    LonNodeInfoSdText             = 3,    /* Query node self-documentation string (LonNmInstallResponse.NodeSd) */
} LON_ENUM_END(LonNodeInfoType);

/*
 *  Enumeration: LonNvOrigin
 *  Defines the origins of a network variable.  Use the LON_NV_DESC_ORIGIN_* 
 *  macros with the <LonNmInstallResponse> union.
 */
typedef LON_ENUM_BEGIN(LonNvOrigin) 
{
    LonNvOriginUndefined    = 0,    /* Not currently defined */
    LonNvOriginStatic       = 1,    /* Statically defined    */
    LonNvOriginDynamic      = 2,    /* Dynamically defined   */
} LON_ENUM_END(LonNvOrigin);

/* 
 *  Macro: LON_NM_FAILURE
 *  Failure response codes for network management and diagnostic classes of 
 *  messages.
 */
#define LON_NM_FAILURE(c)            ((c) & 0x1F)

/*
 *  Macro: LON_NM_SUCCESS
 *  Success response codes for network management and diagnostic classes of 
 *  messages.
 */
#define LON_NM_SUCCESS(c)            (LON_NM_FAILURE(c) | 0x20)

/*
 *  Macro: LON_NV_NAME_LEN
 *  The maximum number of bytes in a network variable name, not including the 0 
 *  terminator.
 *
 */
#define LON_NV_NAME_LEN 16

/* 
 *  The following LON_NM_* and LON_ND_* macros define offsets and masks for 
 *  constructing request and response codes. 
 */
#define LON_NM_OPCODE_BASE      0x60
#define LON_NM_OPCODE_MASK      0x1F
#define LON_NM_RESPONSE_MASK    0xE0
#define LON_NM_RESPONSE_SUCCESS 0x20
#define LON_NM_RESPONSE_FAILED  0x00

#define LON_ND_OPCODE_BASE      0x50
#define LON_ND_OPCODE_MASK      0x0F
#define LON_ND_RESPONSE_MASK    0xF0
#define LON_ND_RESPONSE_SUCCESS 0x30
#define LON_ND_RESPONSE_FAILED  0x10

/*
 *  Typedef: LonCorrelator
 *  Data structure used for correlating requests and responses.
 *
 *  LonCorrelator is used to correlate request messages and their responses.
 */
typedef const void *LonCorrelator;

/*
 *  Typedef: LonResetNotification
 *  Structure for uplink reset message.
 *
 *  This type is used in the Reset callback, to provide call compatibility with 
 *  ShortStack.  However, IzoT does not provide extended reset information at 
 *  this time.
 */
typedef void LonResetNotification;

/* 
 *  Typedef: LonNmNvFetchRequest
 *  Message structure for a NV fetch request.
 */
typedef LON_STRUCT_BEGIN(LonNmNvFetchRequest) 
{
    LonByte  Index;
    LonWord  EscapeIndex;  /* exists iff index==0xFF    */
} LON_STRUCT_END(LonNmNvFetchRequest);

/*
 *  Typedef: LonNmInstallRequest
 *  Message structure used with *LonNmInstall* requests.
 *
 *  Each member of this union contains a *Command* field (<LonInstallCommand>)
 *  that specifies the command type.  Even though this structure is defined as
 *  a union, the message size should include only the fields required for the
 *  particular command type.
 */

typedef LON_UNION_BEGIN(LonNmInstallRequest) 
{
    LON_STRUCT_NESTED_BEGIN(Wink)
    {
        LON_ENUM(LonInstallCommand) Command; /* *LonInstallWink* */
    } LON_STRUCT_NESTED_END(Wink);

    LON_STRUCT_NESTED_BEGIN(QueryNvInfo)
    {
        LON_ENUM(LonInstallCommand) Command;     /* *LonInstallQueryNvInfo* */
        LON_ENUM(LonNvInfoType)     NvInfoType;  /* Requested network variable information */
        LonWord                     NvIndex;     /* Network variable index */

        /* The following parameters are used only if NvInfoType is 
         * *LonNvInfoSdText*, and should be omitted when other types of NV 
         * information are being queried.
         */
        LON_UNION_NESTED_BEGIN(AdditionalParameters)
        {
            LON_STRUCT_NESTED_BEGIN(SdText)
            {
                /* Used when NvInfoType is *LonNvInfoSdText* */
                LonWord Offset;         /* Byte offset from beginning of SD text */
                LonByte Length;         /* Maximum number of SD bytes to return  */
            } LON_STRUCT_NESTED_END(SdText);
        } LON_UNION_NESTED_END(AdditionalParameters);
    } LON_STRUCT_NESTED_END(QueryNvInfo);

    LON_STRUCT_NESTED_BEGIN(QueryNodeInfo)
    {
        LON_ENUM(LonInstallCommand) Command;      /* *LonInstallQueryNodeInfo*  */
        LON_ENUM(LonNodeInfoType)   NodeInfoType; /* Requested node information */
        LON_UNION_NESTED_BEGIN(AdditionalParameters)
        {
            LON_STRUCT_NESTED_BEGIN(SdText)
            {
                /* Used when NodeInfoType is *LonNodeInfoSdText* */
                LonWord Offset;        /* Byte offset from beginning of SD text */
                LonByte Length;        /* Maximum number of SD bytes to return  */
            } LON_STRUCT_NESTED_END(SdText);
        } LON_UNION_NESTED_END(AdditionalParameters);
    } LON_STRUCT_NESTED_END(QueryNodeInfo);

} LON_UNION_END(LonNmInstallRequest);

/*
 *  Typedef: LonNmInstallResponse
 *  Message structure used with *LonNmInstall* responses.
 *
 */

/*
 * Use the LON_NV_DESC_LENGTH_* macros to access the length field in 
 * LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_LENGTH_MASK   0xf8    /* Network variable length */
#define LON_NV_DESC_LENGTH_SHIFT  3
#define LON_NV_DESC_LENGTH_FIELD  LengthAndOrigin

/*
 * Use the LON_NV_DESC_ORIGIN_* macros to access the origin field in 
 * LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_ORIGIN_MASK   0x07    /* Origin.  Use LonNvOrigin. */
#define LON_NV_DESC_ORIGIN_SHIFT  0
#define LON_NV_DESC_ORIGIN_FIELD  LengthAndOrigin

/*
 * Use the LON_NV_DESC_IS_OUTPUT_* macros to access the direction field in 
 * LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_IS_OUTPUT_MASK   0x10    /* 1: output, 0: input */
#define LON_NV_DESC_IS_OUTPUT_SHIFT  4
#define LON_NV_DESC_IS_OUTPUT_FIELD  Defaults

/*
 * Use the LON_NV_DESC_DFLT_AUTH_* macros to access the default authentication 
 * field in LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_DFLT_AUTH_MASK   0x08    /* 1: authenticated, 0: unauthenticated */
#define LON_NV_DESC_DFLT_AUTH_SHIFT  3
#define LON_NV_DESC_DFLT_AUTH_FIELD  Defaults

/*
 * Use the LON_NV_DESC_DFLT_PRIORITY_* macros to access the default priority 
 * field in LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_DFLT_PRIORITY_MASK   0x04    /* 1: priority, 0: non-priority */
#define LON_NV_DESC_DFLT_PRIORITY_SHIFT  2
#define LON_NV_DESC_DFLT_PRIORITY_FIELD  Defaults

/*
 * Use the LON_NV_DESC_DFLT_SERVICE_* macros to access the service field in 
 * LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_DFLT_SERVICE_MASK   0x03    /* default service type.  Use LonServiceType. */
#define LON_NV_DESC_DFLT_SERVICE_SHIFT  0
#define LON_NV_DESC_DFLT_SERVICE_FIELD  Defaults

/*
 * Use the LON_NV_DESC_ATTR_SYNC_* macros to access the nv_sync field in 
 * LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_ATTR_SYNC_MASK   0x40    /* 1: sync NV, 0: non-sync NV */
#define LON_NV_DESC_ATTR_SYNC_SHIFT  6
#define LON_NV_DESC_ATTR_SYNC_FIELD  BasicAttributes

/*
 * Use the LON_NV_DESC_ATTR_POLLED_* macros to access the nv_polled field in 
 * LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_ATTR_POLLED_MASK   0x20    /* 1: polled or polling input, 0: not polled */
#define LON_NV_DESC_ATTR_POLLED_SHIFT  5
#define LON_NV_DESC_ATTR_POLLED_FIELD  BasicAttributes

/*
 * Use the LON_NV_DESC_ATTR_OFFLINE_* macros to access the nv_offline field in 
 * LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_ATTR_OFFLINE_MASK   0x10    /* 1: take offline prior to updating */
#define LON_NV_DESC_ATTR_OFFLINE_SHIFT  4
#define LON_NV_DESC_ATTR_OFFLINE_FIELD  BasicAttributes

/*
 * Use the LON_NV_DESC_ATTR_SRVC_TYPE_CONFIG_* macros to access the 
 * nv_service_type_config field in LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_ATTR_SRVC_TYPE_CONFIG_MASK   0x08    /* 1: service type is configurable */
#define LON_NV_DESC_ATTR_SRVC_TYPE_CONFIG_SHIFT  3
#define LON_NV_DESC_ATTR_SRVC_TYPE_CONFIG_FIELD  BasicAttributes

/*
 * Use the LON_NV_DESC_ATTR_PRIORITY_CONFIG_* macros to access the 
 * nv_priority_config field in LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_ATTR_PRIORITY_CONFIG_MASK   0x04    /* 1: priority flag is configurable */
#define LON_NV_DESC_ATTR_PRIORITY_CONFIG_SHIFT  2
#define LON_NV_DESC_ATTR_PRIORITY_CONFIG_FIELD  BasicAttributes

/*
 * Use the LON_NV_DESC_ATTR_AUTH_CONFIG_* macros to access the nv_auth_config 
 * field in LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_ATTR_AUTH_CONFIG_MASK   0x02    /* 1: authentication flag is configurable */
#define LON_NV_DESC_ATTR_AUTH_CONFIG_SHIFT  1
#define LON_NV_DESC_ATTR_AUTH_CONFIG_FIELD  BasicAttributes

/*
 * Use the LON_NV_DESC_ATTR_CONFIG_CLASS_* macros to access the 
 * nv_config_class field in LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_ATTR_CONFIG_CLASS_MASK   0x01    /* 1: a config NV, 0: non-config NV */
#define LON_NV_DESC_ATTR_CONFIG_CLASS_SHIFT  0
#define LON_NV_DESC_ATTR_CONFIG_CLASS_FIELD  BasicAttributes

/*
 * Use the LON_NV_DESC_EXT_ATTR_MRE_AVAIL_* macros to access the max rate 
 * estimate (mre) field in LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_EXT_ATTR_MRE_AVAIL_MASK   0x80    /* 1: Max rate estimate available using LonInstallQueryNvInfo, LonNvInfoRateEstimate */
#define LON_NV_DESC_EXT_ATTR_MRE_AVAIL_SHIFT  7
#define LON_NV_DESC_EXT_ATTR_MRE_AVAIL_FIELD  ExtendedAttributes

/*
 * Use the LON_NV_DESC_EXT_ATTR_RE_AVAIL_* macros to access the rate estimate 
 * (re) field in LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_EXT_ATTR_RE_AVAIL_MASK   0x40    /* 1: Average rate estimate available using LonInstallQueryNvInfo, LonNvInfoRateEstimate */
#define LON_NV_DESC_EXT_ATTR_RE_AVAIL_SHIFT  6
#define LON_NV_DESC_EXT_ATTR_RE_AVAIL_FIELD  ExtendedAttributes

/*
 * Use the LON_NV_DESC_EXT_ATTR_NAME_AVAIL_* macros to access the nv_name 
 * field in LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_EXT_ATTR_NAME_AVAIL_MASK   0x20    /* 1: NV Name is available using LonInstallQueryNvInfo, LonNvInfoName. */
#define LON_NV_DESC_EXT_ATTR_NAME_AVAIL_SHIFT  5
#define LON_NV_DESC_EXT_ATTR_NAME_AVAIL_FIELD  ExtendedAttributes

/*
 * Use the LON_NV_DESC_EXT_ATTR_SD_AVAIL_* macros to access the sd field in 
 * LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_EXT_ATTR_SD_AVAIL_MASK   0x10    /* 1: NV SD text is available using LonInstallQueryNvInfo, LonNvInfoSdText  */
#define LON_NV_DESC_EXT_ATTR_SD_AVAIL_SHIFT  4
#define LON_NV_DESC_EXT_ATTR_SD_AVAIL_FIELD  ExtendedAttributes

/*
 * Use the LON_NV_DESC_EXT_ATTR_NAME_SUPPLIED_* macros to access the 
 * name_supplied field in LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_EXT_ATTR_NAME_SUPPLIED_MASK   0x08    /* 1: Name is supplied in LonNmInstallResponse.NvDescriptor */
#define LON_NV_DESC_EXT_ATTR_NAME_SUPPLIED_SHIFT  3
#define LON_NV_DESC_EXT_ATTR_NAME_SUPPLIED_FIELD  ExtendedAttributes

typedef LON_UNION_BEGIN(LonNmInstallResponse) 
{
    /* Response for requested info LonInstallQueryNvInfo, LonNvInfoDescriptor */
    LON_STRUCT_NESTED_BEGIN(NvDescriptor)
    {
        LonByte LengthAndOrigin;    /* Use LON_NV_DESC_LENGTH_* and LON_NV_DESC_ORIGIN_* macros */
        LonByte Defaults;           /* Use LON_NV_DESC_IS_OUTPUT_* and LON_NV_DESC_DFLT_* macros */
        LonByte BasicAttributes;    /* Use LON_NV_DESC_ATTR_* macros */
        LonByte SnvtIndex;
        LonByte ExtendedAttributes; /* Use LON_NV_DESC_EXT_ATTR_* macros */
        LonWord ArraySize;
        LonWord ArrayElement;
        char    NvName[LON_NV_NAME_LEN]; /* Optional field - Included only if
                                        LON_NV_DESC_EXT_ATTR_NAME_SUPPLIED flag is set. */
    } LON_STRUCT_NESTED_END(NvDescriptor);

    /* Response for requested info LonInstallQueryNvInfo, LonNvInfoRateEstimate */
    LON_STRUCT_NESTED_BEGIN(NvRate)
    {
        LonByte    RateEstimate;       /* Encoded rate estimate. Only valid if 'LON_NV_DESC_EXT_ATTR_RE_AVAIL' is set in NvDescriptor. */
        LonByte    MaxRateEstimate;    /* Encoded max rate estimate. Only valid if 'LON_NV_DESC_EXT_ATTR_MRE_AVAIL' is set in NvDescriptor. */
    } LON_STRUCT_NESTED_END(NvRate);

    /* Response for requested info LonInstallQueryNvInfo,  LonNvInfoName */
    char    NvName[LON_NV_NAME_LEN];   /* NV name. Only valid if 'nm' set in NV NvDescriptor. */

    /* Response for requested info LonInstallQueryNvInfo, LonNvInfoSdText */
    LON_STRUCT_NESTED_BEGIN(NvSd)
    {
        LonByte    Length;      /* Number of bytes of SD text returned */
        LonByte    Text[1];     /* SD text - actual length is Length above. 
                                 * Might not be NULL terminated. */
    } LON_STRUCT_NESTED_END(NvSd);

    /* Response for requested info LonInstallQueryNvInfo, LonNvInfoSnvtIndex */
    LonByte    SnvtTypeIndex;

    /* Response for requested info LonInstallQueryNodeInfo, LonNodeInfoSdText */
    LON_STRUCT_NESTED_BEGIN(NodeSd)
    {
        LonByte    Length;      /* Number of bytes of SD text returned */
        LonByte    Text[1];     /* SD text - actual length is Length above. 
                                 * Might not be NULL terminated. */
    } LON_STRUCT_NESTED_END(NodeSd);
} LON_UNION_END(LonNmInstallResponse) ;

/* 
 *  Typedef: LonNmSetNodeModeRequest
 *  Message structure for standard network management command *LonNmSetNodeMode*.
 */
typedef LON_STRUCT_BEGIN(LonNmSetNodeModeRequest) 
{
    LON_ENUM(LonNodeMode)     Mode;
    LON_ENUM(LonNodeState)    State;  /* iff mode == LonChangeState */
} LON_STRUCT_END(LonNmSetNodeModeRequest);

/*
 *  Enumeration: LonMemoryReadWriteMode
 *  Defines addressing mode for memory read and write request.
 */
typedef LON_ENUM_BEGIN(LonMemoryReadWriteMode) 
{
    LonAbsoluteMemory           = 0,         /* Address is absolute Smart Transceiver memory address */
    LonReadOnlyRelative         = 1,         /* Address is offset into read-only memory structures */
    LonConfigStructRelative     = 2,         /* Address is offset into configuration data structures */
    LonStatisticStructRelative  = 3,         /* Address is offset into statistics data structures */
    LonMemoryModeReserved_A     = 4          /* Reserved for Echelon internal use only */
} LON_ENUM_END(LonMemoryReadWriteMode);

/*
 *  Enumeration: LonMemoryWriteForm
 *  Defines actions that follow a memory write request. 
 */  
typedef LON_ENUM_BEGIN(LonMemoryWriteForm) 
{
    LonNoAction                   = 0,
    LonBothCsRecalculation        = 1,
    LonDeltaCsRecalculation       = 3,
    LonConfigCsRecalculation      = 4,
    LonOnlyReset                  = 8,
    LonBothCsRecalculationReset   = 9,
    LonConfigCsRecalculationReset = 12
} LON_ENUM_END(LonMemoryWriteForm);

/* 
 *  Typedef: LonNmReadMemoryRequest
 *  Message structure used with the *LonNmReadMemory* request.
 */
typedef LON_STRUCT_BEGIN(LonNmReadMemoryRequest) 
{
    LON_ENUM(LonMemoryReadWriteMode)     Mode;
    LonWord        Address;
    LonByte     Count;
} LON_STRUCT_END(LonNmReadMemoryRequest);

/*
 *  Typedef: LonNmWriteMemoryRequest
 *  Message structure used with the *LonNmWriteMemory* request.
 *
 *  Note that this structure shows only the message header. The message header 
 *  is followed by the data to write, which must be *count* bytes following 
 *  the field *Form*.
 */
typedef LON_STRUCT_BEGIN(LonNmWriteMemoryRequest) 
{
    LON_ENUM(LonMemoryReadWriteMode)    Mode;
    LonWord     Address;
    LonByte     Count;
    LON_ENUM(LonMemoryWriteForm)        Form;
    /* <count> bytes of data following... */
} LON_STRUCT_END(LonNmWriteMemoryRequest);

/*
 *  Enumeration: LonApplicationMessageCode
 *  Message codes used with application messages.
 *
 *  Application message codes are in the [LonApplicationMsg, LonForeignMsg] 
 *  range, but selected values are frequently used and should be avoided: 
 *  LonApplicationIsi is used by the Interoperable Self-Installation (ISI) 
 *  protocol, and LonApplicationFtp is used for the interoperable file 
 *  transfer protocol (FTP). 
 */
typedef LON_ENUM_BEGIN(LonApplicationMessageCode) 
{
    LonApplicationMsg        = 0x00,
    LonApplicationIsi        = 0x3D,
    LonApplicationFtp        = 0x3E,
    LonApplicationIsOffLine  = 0x3F,
    LonForeignMsg            = 0x40,
    LonForeignIsOffLine      = 0x4F,
    LonLastMessageCode       = 0x4F
} LON_ENUM_END(LonApplicationMessageCode);

/*
 *  Typedef: LonNmQueryDomainRequest
 *  Message structure used with *LonNmQueryDomain*.
 */
typedef LON_STRUCT_BEGIN(LonNmQueryDomainRequest) 
{
    LonByte Index;             /* Domain index                 */
} LON_STRUCT_END(LonNmQueryDomainRequest);

/*
 *  Typedef: LonNmQueryNvAliasRequest
 *  Message structure used with *LonNmQueryNvConfig*.
 *
 */
typedef LON_STRUCT_BEGIN(LonNmQueryNvAliasRequest) 
{
    LonWord  Index;             /* Nv config table index                 */
} LON_STRUCT_END(LonNmQueryNvAliasRequest);

/*
 *  Typedef: LonNmQueryAddressRequest
 *  Message structure used with *LonNmQueryAddr*.
 */
typedef LON_STRUCT_BEGIN(LonNmQueryAddressRequest) 
{
    LonByte Index;             /* address table index                 */
} LON_STRUCT_END(LonNmQueryAddressRequest);

/*
 *  Typedef: LonNdQueryStatusResponse
 *  Message structure used with responses to *LonNdQueryStatus*.
 */
typedef LON_STRUCT_BEGIN(LonNdQueryStatusResponse) 
{
    LonStatus    Status;
} LON_STRUCT_END(LonNdQueryStatusResponse);

/*
 *  Typedef: LonNdQueryXcvrResponse
 *  Message structure used with responses to *LonNdQueryXcvr*.
 */
typedef LON_STRUCT_BEGIN(LonNdQueryXcvrResponse) 
{
    LonTransceiverParameters    Status;
} LON_STRUCT_END(LonNdQueryXcvrResponse);

/*
 *  Typedef: LonNmUpdateAddressRequest
 *  Message structure used with *LonNmUpdateAddr* requests.
 */
typedef LON_STRUCT_BEGIN(LonNmUpdateAddressRequest) 
{
    LonByte      Index;
    LonAddress   Address;
} LON_STRUCT_END(LonNmUpdateAddressRequest);

/* 
 *  Typedef: LonNmUpdateNvRequest
 *  Message structure used with *LonNmUpdateNvConfig* requests.
 *
 *  This structure is used to update the network variable configuration table. 
 *  The structure exists in two forms. If the 'ShortIndex' field is in the 
 *  range 0..254, use the ShortForm union member. If the short index equals 
 *  255, use the LongForm union member and obtain the true index from the 
 *  LongIndex field. Note that the data structure shown is an abstraction; the 
 *  actual message frame used is the smallest possible. 
 */
typedef LON_STRUCT_BEGIN(LonNmUpdateNvRequest) 
{
    LonByte      ShortIndex;

    LON_UNION_NESTED_BEGIN(Request) 
    {
        LON_STRUCT_NESTED_BEGIN(ShortForm) 
        {
            LonNvConfig     NvConfig;
        } LON_STRUCT_NESTED_END(ShortForm);
        LON_STRUCT_NESTED_BEGIN(LongForm) 
        {
            LonWord         LongIndex;
            LonNvConfig     NvConfig;
        } LON_STRUCT_NESTED_END(LongForm);
    } LON_UNION_NESTED_END(Request);
} LON_STRUCT_END(LonNmUpdateNvRequest);

/* 
 *  Typedef: LonNmUpdateAliasRequest
 *  Message structure used with *LonNmUpdateNvConfig* requests.
 *
 *  This structure is used to update the alias configuration table. The 
 *  structure exists in two forms. If the 'ShortIndex' field is in the range 
 *  0..254, use the ShortForm union member. If the short index equals 255, use 
 *  the LongForm union member and obtain the true index from the LongIndex 
 *  field. The index should be that of the alias plus the network variable 
 *  count; the alias table follows the network variable config table and the 
 *  index continues from that table.  Note that the data structure shown is an 
 *  abstraction; the actual message frame used is the smallest possible. 
 */
typedef LON_STRUCT_BEGIN(LonNmUpdateAliasRequest) 
{
    LonByte      ShortIndex;

    LON_UNION_NESTED_BEGIN(Request) 
    {
        LON_STRUCT_NESTED_BEGIN(ShortForm) 
        {
            LonAliasConfig  AliasConfig;
        } LON_STRUCT_NESTED_END(ShortForm);
        LON_STRUCT_NESTED_BEGIN(LongForm) 
        {
            LonWord         LongIndex;
            LonAliasConfig  AliasConfig;
        } LON_STRUCT_NESTED_END(LongForm);
    } LON_UNION_NESTED_END(Request);
} LON_STRUCT_END(LonNmUpdateAliasRequest);

/*
 *  Typedef: LonNmUpdateDomainRequest
 *  Message structure used with the *LonNmUpdateDomain* request.
 */
typedef LON_STRUCT_BEGIN(LonNmUpdateDomainRequest) 
{
    LonByte     Index;
    LonDomain   Domain;
} LON_STRUCT_END(LonNmUpdateDomainRequest);

/*
 *  Enumeration: LonServiceType
 *  Literals for the service type.
 */
typedef LON_ENUM_BEGIN(LonServiceType) 
{
    LonServiceAcknowledged       = 0,    /* ACKD         */
    LonServiceRepeated           = 1,    /* UNACKD_RPT   */
    LonServiceUnacknowledged     = 2,    /* UNACKD       */
    LonServiceRequest            = 3     /* REQUEST      */
} LON_ENUM_END(LonServiceType);

/*
 * *****************************************************************************
 * SECTION: NON-VOLATILE DATA
 * *****************************************************************************
 * 
 * This section contains the enumerations and data types used for non-volatile 
 * data (NVD) support.
 */

/*
 * Enumeration: LonNvdSegmentType
 * Non-volatile data segment type. Configuration data is stored persistently
 * in non-volatile data segments, identified using this enumeration.  Used
 * by the non-volatile callback functions LonNvdxxx.
 *
 */
typedef LON_ENUM_BEGIN(LonNvdSegmentType) 
{
    LonNvdSegNetworkImage,      /* Basic network configuration, such as the 
                                   domain table, address tables, and network 
                                   variable configuration. 
                                 */
    LonNvdSegNodeDefinition,    /* Definitions that affect the current 
                                   interface, including dynamic network variable 
                                   definitions. 
                                 */
    LonNvdSegApplicationData,   /* Application data, such as CP values, that 
                                   needs to be stored persistently.  Note that 
                                   in some devices, this can include CP values 
                                   implemented by network variables, CP values 
                                   defined in files, or both. 
                                 */
    LonNvdSegUniqueId,          /* Unique ID defined in file for the IP852 device */
    IsiNvdSegConnectionTable,   /* ISI connection table */
    IsiNvdSegPersistent,        /* Other ISI persistence information */
    LonNvdSegNumSegmentTypes
} LON_ENUM_END(LonNvdSegmentType);

/*
 * Enumeration: PersistenceResetType
 * Used by the <LonResetPersistence> to reset the presistence data files
 *
 */
typedef LON_ENUM_BEGIN(PersistenceResetType) 
{
    PersistenceResetAll,                /* Remove all presistence data files */
    PersistenceResetPreserveUniqueId,   /* Remove all presistence data files, except LonNvdSegUniqueId */
    PersistenceNumResetType
} LON_ENUM_END(PersistenceResetType);

/*
 *  Typedef: LonNvdHandle
 *  A handle to an open non-volatile data segment.  Returned by the 
 *  LonNvdOpenxxx callbacks, and used by the <LonNvdRead>, <LonNvdWrite>, and 
 *  <LonNvdClose> callbacks.
 */
typedef void *LonNvdHandle;

/*
 * *****************************************************************************
 * SECTION: LONTALK INTERFACE DEVELOPER
 * *****************************************************************************
 * 
 * This section contains the enumerations and data types used by the LonTalk
 * Interface Developer.  These types are not typically used directly by the
 * IzoT application.
 */

/*
 *  Macro: LON_STACK_INTERFACE_CURRENT_VERSION
 *  The current version of the <LonStackInterfaceData> structure.
 *
 */
#define LON_STACK_INTERFACE_CURRENT_VERSION 0

/*
 *  Macro: LON_CONTROL_DATA_CURRENT_VERSION
 *  The current version of the <LonControlData> structure.
 *
 */
#define LON_CONTROL_DATA_CURRENT_VERSION 0

/*
 *  Macro: FTXL_NUM_COMM_BYTES
 *  The number of bytes of communication parameter data.
 *
 */
#define FTXL_NUM_COMM_BYTES 16

/* 
 *  Enumeration: FtxlTransceiverType
 *  IzoT Transceiver type.
 *
 *  This enumeration lists all transceivers supported by IzoT.
 */
typedef LON_ENUM_BEGIN(FtxlTransceiverType) 
{
    FtxlTransceiverTypeDefault, 
    FtxlTransceiverType5MHz,
    FtxlTransceiverType10MHz,
    FtxlTransceiverType20MHz,
    FtxlTransceiverType40MHz,
    FtxlTransceiverTypeCustom,
} LON_ENUM_END(FtxlTransceiverType);

/*
 *  Typedef: LonStackInterfaceData
 *  IzoT programmatic interface.  
 *
 *  The <LonStackInterfaceData> contains data generated by LonTalk Interface Developer to define the 
 *  static attributes of the program.  
 */
typedef LON_STRUCT_BEGIN(LonStackInterfaceData)
{
    unsigned Version;               /* Format version number for future 
                                       extensions.  If the IzoT  
                                       protocol stack does not recognize the 
                                       version, it will be rejected.  The 
                                       current version is 
                                       LON_STACK_INTERFACE_CURRENT_VERSION. */
    unsigned Signature;             /* 32-bit unique numerical application 
                                       identifier, generated by the LonTalk 
                                       Interface Developer.  Determines all 
                                       non-volatile configuration aspects. */
    LonProgramId ProgramId;         /* Program ID string (array of 8 bytes) */
    unsigned StaticNvCount;         /* Number of static network variables */
    unsigned NvTblSize;                /* Maximum number of network variables 
                                       (0..4096).  This is the maximum total 
                                       number of static and dynamic NVs. */
    unsigned DomainTblSize;         /* Number of domain in the node (1 or 2) */
    unsigned AddrTblSize;           /* Maximum number of address table entries 
                                       (0..4096) */
    unsigned AliasTblSize;          /* Maximum number of alias tables (0..8192) */
    unsigned BindableMsgTagCount;   /* Number of bindable message tags (0.. 4096) */
    char *NodeSdString;                /* Node self documentation string. */
    unsigned AvgDynNvSdLength;      /* Average number of bytes to reserve for 
                                       dynamic network variable self-
                                       documentation data. 
                                     */
} LON_STRUCT_END(LonStackInterfaceData);

/*
 *  Typedef: LonControlData
 *  IzoT control data.  
 *
 *  The LonControlData structure contains data used to control the runtime 
 *  aspects of the IzoT protocol stack.  These aspects can be set by 
 *  the application at runtime.  The LonTalk Interface Developer generates a 
 *  default control block, which the application can (optionally) modify 
 *  before calling <LonInit>.
 *
 */

typedef LON_STRUCT_BEGIN(LonControlData)
{
    unsigned Version;                /* Format version number for future 
                                       extensions.  Unknown versions will be 
                                       rejected.  The current version is 
                                       <LON_CONTROL_DATA_CURRENT_VERSION>. */
    unsigned ServicePinInterval;    /* The number of seconds that the service 
                                       pin must be pressed before determining
                                       that it has been held, which triggers 
                                       the <LonServicePinHeld> event. If the 
                                       value is 0 then <LonServicePinHeld> 
                                       is disabled.  Legal values are 0-30. */
    unsigned NvdFlushGuardTimeout;  /* The number of seconds to wait after 
                                       receiving an update that affects non-
                                       volatile configuration before starting 
                                       to write the data out.  The internal 
                                       timer gets reset to this guard-band as 
                                       each new update comes in.  Valid range 
                                       is 1 to 60 seconds. */

    /* Defines the communication parameters used by the IzoT 
       protocol stack. */
    LON_STRUCT_BEGIN(CommParmeters)
    {
       /* Transceiver type. If the value is FtxlTransceiverTypeDefault, 
          the comm. parameters in the IzoT Transceiver are left unchanged.
          If the value is FtxlTransceiverTypeCustom, the comm. parameters 
          are set based on the CommParms field.  Otherwise the comm. 
          parameters are modified based on hard-coded comm. parameters 
          for the specified type. */
        FtxlTransceiverType TransceiverType;            

        /* An array of 16 bytes representing the comm. parameters.  If 
           TransceiverType is FtxlTransceiverTypeCustom, these values are 
           written out to the IzoT Transceiver.  Otherwise they are 
           ignored. */
        unsigned char CommParms[FTXL_NUM_COMM_BYTES];    
    } LON_STRUCT_END(CommParmeters);

    /* The number of and size of various buffers used by the IzoT 
       protocol stack. */
    LON_STRUCT_BEGIN(Buffers)
    {
        /* There are three categories of buffers used by the IzoT  
           protocol stack */
        LON_STRUCT_BEGIN(ApplicationBuffers) 
        {
            unsigned PriorityMsgOutCount;       /* Number of priority output 
                                                   message buffers (1 to 100).  
                                                   These are allocated on the 
                                                   host processor.  
                                                   Recommended default = 5. */
            unsigned NonPriorityMsgOutCount;    /* Number of non-priority 
                                                   output message buffers 
                                                   (0 to 100).  These are 
                                                   allocated on the host 
                                                   processor.  Recommended 
                                                   default = 5. */
            unsigned MsgInCount;                /* Number of input message 
                                                   buffers (1 to 100).  
                                                   Recommended default = 10. */
        } LON_STRUCT_END(ApplicationBuffers);

        /* These buffers are also allocated on the host and are used directly 
           by the link-layer driver that communicates with the IzoT 
           Transceiver.  At most, one such buffer is needed for output at any 
           given time, but multiple input buffers might be required.  These 
           buffers are shared for both input and output.  The size of the 
           buffers is determined by the transceiver's network buffer size.   */
        LON_STRUCT_BEGIN(LinkLayerBuffers)
        {
            unsigned LinkLayerBufferCount;  /* Number of driver buffers (1 to 
                                               100).  Recommended default = 2. */
        } LON_STRUCT_END(LinkLayerBuffers);

        /* These are the buffers defined on the IzoT Transceiver.  The 
           application buffers on the transceiver are used only for local 
           network management, and therefore the IzoT protocol stack 
           does not support modifying the application buffers.  The network 
           buffers can be configured.  Because these are defined on the IzoT 
           Transceiver, the counts and sizes must conform to those defined by 
           tables B.1 and B.2 in the EIA/CEA-709.1-B standard, and the total 
           memory requirement specified by the buffers must not exceed the 
           capacity of the transceiver's firmware.  The IzoT Transceiver has 
           hard-coded knowledge of the maximum buffer configuration, and 
           prevents accidentally exceeding these constraints. */
        LON_STRUCT_BEGIN(TransceiverBuffers)
        {
            unsigned NetworkBufferInputSize;      /* Must be at least 66 bytes.  
                                                     Recommended default = 114. */
            unsigned NetworkBufferOutputSize;     /* Must be at least 66 bytes.  
                                                     Recommended default = 114. */
            unsigned PriorityNetworkOutCount;     /* Number of priority 
                                                     network output buffers.  
                                                     Must be non-zero if 
                                                     PriorityMsgOutCount is 
                                                     non-zero.  Recommended 
                                                     default = 2 */
            unsigned NonPriorityNetworkOutCount;  /* Number of non-priority 
                                                     network output buffers.  
                                                     Must be non-zero if 
                                                     NonPriorityMsgOutCount 
                                                     is non-zero.  Default = 2. */
            unsigned NetworkInCount;               /* Number of network input 
                                                     buffers.  Must be non-
                                                     zero.  Recommended 
                                                     default = 5. */
        } LON_STRUCT_END(TransceiverBuffers);
    } LON_STRUCT_END(Buffers);

    /* Maximum number of receive transaction records (1..200) */
    /* A receive transaction record is required for any incoming message 
       which uses either unacknowledged repeat, acknowledged, or request 
       service. No receive transaction entries are required for 
       unacknowledged service. A receive transaction record is required for 
       each unique source address/destination address/priority attribute. 
       Each receive transaction entry contains a current transaction number. 
       A message is considered to be a duplicate if its source address, 
       destination address, and priority attribute vector into an existing 
       receive transaction, and the message's transaction number matches the 
       record's transaction number. 

       A receive transaction record is freed when a new message is received 
       that vectors into an existing receive transaction record, if the 
       message's transaction number *does not* match the transaction number 
       in the receive transaction record.
           
       Receive transaction records are also freed after the receive timer 
       expires. The receive timer duration is determined by the destination 
       device and varies as a function of the message addressing mode. For 
       group addressed messages, the receive timer is determined by the 
       address table. For Unique ID addressed messages, the receive timer 
       is fixed at eight seconds. For other addressing modes, the non-group
       receive timer in the configuration data structure is used.
    */
    unsigned ReceiveTransCount;    

    /* Maximum number of transmit transactions records (1..8192) */
    /* Transmit transaction records are allocated each time a message is 
       sent using the acknowledged, unacknowledged repeated, or request 
       service.  The record is keyed by the source address, destination 
       address, and priority.  A transmit transaction record is used both 
       to maintain information about current transactions and about the 
       most recently completed transactions.  Among other things, the 
       transaction record includes the 4-bit protocol transaction number.  
       The receiving device maintains a corresponding receive 
       transaction until either a new transaction with the same source 
       address, destination address, and priority has been received, or 
       the receive transaction times out.  Therefore, the transmit 
       transaction should also be maintained until either a new 
       transaction is initiated or the receive transaction times out.  
       However, the sending application does not know how long the 
       receive transaction time is.  Instead, the IzoT LonTalk protocol 
       stack's transaction records are released when the 
       TransmitTransIdLifetime timer expires (see below).
           
       If the device uses only implicit transactions, the maximum number 
       of transaction records it could possibly need is 2 times the 
       number of address tables that it has, because the transaction 
       record is keyed by source/destination address AND priority.  If 
       there are sufficient transmit transaction records, the 
       TransmitTransIdLifetime can be very large (though it need never 
       exceed the largest receive transaction timeout, which is 24576 
       milliseconds).
           
       If explicit addressing is used, then the maximum number of 
       transmit transactions is unknowable.  However, there is never a 
       need for more transmit transaction records than there are possible 
       transactions within the TransmitTransIdLifetime.  However, if we 
       assume that the IzoT device can send 70 transactions per second, 
       and the TransmitTransIdLifetime is set to the maximum, the 
       TransmitTransCount would need to be on the order of 1750.  On the 
       other hand, it is extremely unlikely that an all FT network would 
       ever have such long receive transactions, and therefore the 
       TransmitTransIdLifetime could be set much lower.  If there are 
       other slower channels involved, it is unlikely that the IzoT 
       device would be able to send 70 transactions per second.  But 
       unfortunately, there could be configurations where some of the 
       receiving devices have very long receive transactions and the IzoT 
      device can send a lot of transactions per second.
    */
    unsigned TransmitTransCount;

    /* Transmit transaction ID lifetime, in milliseconds.  Recommended 
       default = 24576 (the maximum receive timer).
           
       This value indicates how long a transaction record should remain 
       in use.  You should set it to the value of the largest receive 
       transaction timer for all devices that the IzoT device will send 
       acknowledged, unacknowledged repeat, or request messages to.  
       Because the application is unlikely to know this value, the maximum 
       possible receive timer is used as the recommended default.  This 
       value works well if there are enough transaction table entries for 
       all addressed messages, but if there are not, an application 
       message send could fail because of a lack of transaction records. 
    */
    unsigned TransmitTransIdLifetime;    
} LON_STRUCT_END(LonControlData);

/*
 *  Type definitions for callback and event handers
 */
typedef void (*LonEventReadyFunction)(void);
typedef const unsigned (*LonGetCurrentNvSizeFunction)(const unsigned index);
typedef void (*LonResetFunction)(const LonResetNotification* const pResetNotification);
typedef void (*LonWinkFunction)(void);
typedef void (*LonOfflineFunction)(void);
typedef void (*LonOnlineFunction)(void);
typedef void (*LonServicePinPressedFunction)(void);
typedef void (*LonServicePinHeldFunction)(void);
typedef void (*LonNvUpdateOccurredFunction)(const unsigned index, const LonReceiveAddress* const pSourceAddress);
typedef void (*LonNvUpdateCompletedFunction)(const unsigned index, const LonBool success);
typedef void (*LonNvAddedFunction)(const unsigned index, const LonNvDefinition* const pNvDef);
typedef void (*LonNvTypeChangedFunction)(const unsigned index, const LonNvDefinition* const pNvDef);
typedef void (*LonNvDeletedFunction)(const unsigned index);
typedef void (*LonMsgArrivedFunction)(const LonReceiveAddress* const pAddress,
                          const LonCorrelator correlator,
                          const LonBool priority,
                          const LonServiceType serviceType,
                          const LonBool authenticated,
                          const LonByte code,
                          const LonByte* const pData, const unsigned dataLength);
typedef void (*LonResponseArrivedFunction)(const LonResponseAddress* const pAddress,
                               const unsigned tag,
                               const LonByte code,
                               const LonByte* const pData, const unsigned dataLength);
typedef void (*LonMsgCompletedFunction)(const unsigned tag, const LonBool success);
typedef const LonApiError (*LonMemoryReadFunction)(const unsigned address,
                                const unsigned size,
                                void* const pData);
typedef const LonApiError (*LonMemoryWriteFunction)(const unsigned address,
                                const unsigned size,
                                const void* const pData);
typedef void (*LonServiceLedStatusFunction)(LtServicePinState state);
typedef const LonNvdHandle (*LonNvdOpenForReadFunction)(const LonNvdSegmentType type);
typedef const LonNvdHandle (*LonNvdOpenForWriteFunction)(const LonNvdSegmentType type, const size_t size);
typedef void (*LonNvdCloseFunction)(const LonNvdHandle handle);
typedef void (*LonNvdDeleteFunction)(const LonNvdSegmentType type);
typedef const LonApiError (*LonNvdReadFunction)(const LonNvdHandle handle,
                             const size_t offset,
                             const size_t size,
                             void * const pBuffer);
typedef const LonApiError (*LonNvdWriteFunction)(const LonNvdHandle handle,
                              const size_t offset,
                              const size_t size,
                              const void * const pData);
typedef const LonBool (*LonNvdIsInTransactionFunction)(const LonNvdSegmentType type);
typedef const LonApiError (*LonNvdEnterTransactionFunction)(const LonNvdSegmentType type);
typedef const LonApiError (*LonNvdExitTransactionFunction)(const LonNvdSegmentType type);
typedef const unsigned (*LonNvdGetApplicationSegmentSizeFunction)(void);
typedef const LonApiError (*LonNvdDeserializeSegmentFunction)(const void * const pData,
                                           const size_t          size);
typedef const LonApiError (*LonNvdSerializeSegmentFunction)(const void * const pData,
                                           const size_t          size);
typedef void (*LonNvdStarvationFunction)(const unsigned seconds);

typedef const LonBool (*LonFilterMsgArrivedFunction)(const LonReceiveAddress* const pAddress,
                          const LonCorrelator correlator,
                          const LonBool priority,
                          const LonServiceType serviceType,
                          const LonBool authenticated,
                          const LonByte code,
                          const LonByte* const pData, const unsigned dataLength);

typedef const  LonBool(*LonFilterResponseArrivedFunction)(const LonResponseAddress* const pAddress,
                               const unsigned tag,
                               const LonByte code,
                               const LonByte* const pData, const unsigned dataLength);

typedef const  LonBool(*LonFilterMsgCompletedFunction)(const unsigned tag, const LonBool success);

typedef struct
{
    LonEventReadyFunction           eventReady;
    LonGetCurrentNvSizeFunction     getCurrentNvSize;
    LonResetFunction                reset;
    LonWinkFunction                 wink;
    LonOfflineFunction              offline;
    LonOnlineFunction               online;
    LonServicePinPressedFunction    servicePinPressed;
    LonServicePinHeldFunction       servicePinHeld;
    LonNvUpdateOccurredFunction     nvUpdateOccurred;
    LonNvUpdateCompletedFunction    nvUpdateCompleted;
    LonNvAddedFunction              nvAdded;
    LonNvTypeChangedFunction        nvTypeChanged;
    LonNvDeletedFunction            nvDeleted;
    LonMsgArrivedFunction           msgArrived;
    LonResponseArrivedFunction      responseArrived;
    LonMsgCompletedFunction         msgCompleted;
    LonMemoryReadFunction           memoryRead;
    LonMemoryWriteFunction          memoryWrite;
    LonServiceLedStatusFunction     serviceLedStatus;
// NVD functions
    LonNvdOpenForReadFunction       nvdOpenForRead;
    LonNvdOpenForWriteFunction      nvdOpenForWrite;
    LonNvdCloseFunction             nvdClose;
    LonNvdDeleteFunction            nvdDelete;
    LonNvdReadFunction              nvdRead;
    LonNvdWriteFunction             nvdWrite;
    LonNvdIsInTransactionFunction   nvdIsInTransaction;
    LonNvdEnterTransactionFunction  nvdEnterTransaction;
    LonNvdExitTransactionFunction   nvdExitTransaction;
    LonNvdGetApplicationSegmentSizeFunction nvdGetApplicationSegmentSize;
    LonNvdDeserializeSegmentFunction    nvdDeserializeSegment;
    LonNvdSerializeSegmentFunction  nvdSerializeSegment;
    LonNvdStarvationFunction        nvdStarvation;
// ISI functions
    LonFilterMsgArrivedFunction         filterMsgArrived;
    LonFilterResponseArrivedFunction    filterResponseArrived;
    LonFilterMsgCompletedFunction       filterMsgCompleted;
}   LonCallbackVectors;

#endif /* _FTXL_TYPES_H */
